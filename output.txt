include/net/ipv6.h:57: *	type	-	unicast | multicast
include/net/ip.h:331: *	Map a multicast IP onto multicast MAC for type ethernet.
include/net/ip.h:348: *	Map a multicast IP onto multicast MAC for type IP-over-InfiniBand.
include/net/genetlink.h:11: * struct genl_multicast_group - generic netlink multicast group
include/net/genetlink.h:12: * @name: name of the multicast group, names are per-family
include/net/genetlink.h:36: * @mcgrps: multicast groups used by this family (private)
include/net/genetlink.h:37: * @n_mcgrps: number of multicast groups (private)
include/net/genetlink.h:38: * @mcgrp_offset: starting number of multicast group IDs in this family
include/net/genetlink.h:260: * genlmsg_multicast_netns - multicast a netlink message to a specific netns
include/net/genetlink.h:265: * @group: offset of multicast group in groups array
include/net/genetlink.h:279: * genlmsg_multicast - multicast a netlink message to the default netns
include/net/genetlink.h:283: * @group: offset of multicast group in groups array
include/net/genetlink.h:295: * genlmsg_multicast_allns - multicast a netlink message to all net namespaces
include/net/genetlink.h:299: * @group: offset of multicast group in groups array
include/net/genetlink.h:382: * 	(this is the offset of the multicast group in the groups array)
include/net/addrconf.h:123: *	multicast prototypes (mcast.c)
include/net/addrconf.h:297: *	compute link-local solicited-node multicast address
include/net/wimax.h:92: * signals over a multicast group named "msg".
include/net/wimax.h:103: * over multicast groups. This allows to have multiple applications
include/net/wimax.h:133: * and the multicast groups available can be found. Applications using
include/net/netlink.h:45: *   nlmsg_multicast()			multicast message to several groups
include/net/netlink.h:550: * nlmsg_multicast - multicast a netlink message
include/net/netlink.h:554: * @group: multicast group id
include/net/cfg80211.h:1674: * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
include/net/cfg80211.h:2141: * @set_mcast_rate: Set the specified multicast rate (only if vif is in ADHOC or
include/net/cfg80211.h:2291:				   u8 key_index, bool unicast, bool multicast);
include/net/cfg80211.h:4037: * vendor-specific multicast group.
include/net/cfg80211.h:4133: * testmode multicast group.
include/net/mac80211.h:316: * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
include/net/mac80211.h:1025: *	needs to check for the multicast traffic bit in DTIM beacons.
include/net/mac80211.h:1443: *	Some wireless LAN chipsets buffer broadcast/multicast frames
include/net/mac80211.h:1447: *	multicast frames when there are power saving stations so that
include/net/mac80211.h:1867: * buffered multicast/broadcast frames after the beacon. Also it must be
include/net/mac80211.h:1875: * waking up for multicast traffic; if it cannot the driver must handle that
include/net/mac80211.h:2007: * for the combined multicast address list of all virtual interfaces.
include/net/mac80211.h:2013: * If your device has no multicast address filters your driver will
include/net/mac80211.h:2015: * parameter to see whether multicast frames should be accepted
include/net/mac80211.h:2196: * @FIF_ALLMULTI: pass all multicast frames, this is used if requested
include/net/mac80211.h:2198: *	multicast address.
include/net/mac80211.h:2412: * @prepare_multicast: Prepare for multicast filter configuration.
include/net/mac80211.h:2796:				 u64 multicast);
include/net/mac80211.h:3345: * multicast frames but this can affect statistics.
include/net/mac80211.h:3630: * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames
include/net/mac80211.h:3634: * Function for accessing buffered broadcast and multicast frames. If
include/net/mac80211.h:3635: * hardware/firmware does not implement buffering of broadcast/multicast
include/net/mac80211.h:4499: * rate for multicast/broadcast frames may choose to not use this.
include/net/cfg80211.h~:1674: * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
include/net/cfg80211.h~:2141: * @set_mcast_rate: Set the specified multicast rate (only if vif is in ADHOC or
include/net/cfg80211.h~:2291:				   u8 key_index, bool unicast, bool multicast);
include/net/cfg80211.h~:4037: * vendor-specific multicast group.
include/net/cfg80211.h~:4133: * testmode multicast group.
include/net/ip_vs.h:984:	/* multicast interface name */
include/uapi/sound/asequencer.h:346:#define SNDRV_SEQ_FILTER_MULTICAST	(1<<1)	/* accept multicast messages */
include/uapi/sound/asequencer.h:355:	unsigned char multicast_filter[8]; /* multicast filter bitmap */
include/uapi/scsi/fc/fc_fs.h:165:	FC_FID_MCAST_SERV =	0xfffff5,	/* multicast server */
include/uapi/scsi/fc/fc_fs.h:336:	FC_RJT_MCAST_ERR =	0x22,	/* multicast error */
include/uapi/scsi/fc/fc_fs.h:337:	FC_RJT_MCAST_ET =	0x23,	/* multicast error terminate */
include/uapi/scsi/fc/fc_els.h:264:#define	FC_SP_FT_MCAST	0x0200	/* multicast */
include/uapi/linux/capability.h:170:/* Allow broadcasting, listen to multicast */
include/uapi/linux/virtio_net.h:143: * first sg list contains unicast addresses, the second is for multicast.
include/uapi/linux/if.h:40:#define	IFF_ALLMULTI	0x200		/* receive all multicast packets*/
include/uapi/linux/if.h:45:#define IFF_MULTICAST	0x1000		/* Supports multicast		*/
include/uapi/linux/usb/cdc.h:261:/* table 62; bits in multicast filter */
include/uapi/linux/igmp.h:125: * struct for keeping the multicast list in
include/uapi/linux/if_link.h:17:	__u32	multicast;		/* multicast packets received	*/
include/uapi/linux/if_link.h:50:	__u64	multicast;		/* multicast packets received	*/
include/uapi/linux/if_link.h:184:   for multicast frames. Apparently, all IFF_POINTOPOINT and
include/uapi/linux/if_link.h:224:	IFLA_BRPORT_FAST_LEAVE,	/* multicast fast leave    */
include/uapi/linux/if_link.h:540:	IFLA_HSR_SUPERVISION_ADDR,	/* Supervision frame multicast addr */
include/uapi/linux/nl80211.h:131: * In most cases, host that receives IPv4 and IPv6 multicast/broadcast
include/uapi/linux/nl80211.h:291: *	NL80211_CMD_GET_SCAN and on the "scan" multicast group)
include/uapi/linux/nl80211.h:321: *	NL80211_CMD_GET_SURVEY and on the "scan" multicast group)
include/uapi/linux/nl80211.h:358: *	as an event on the "mlme" multicast group indicating completion of the
include/uapi/linux/nl80211.h:393: *	MIC (part of TKIP) failure; sent on the "mlme" multicast group; the
include/uapi/linux/nl80211.h:643: * @NL80211_CMD_SET_MCAST_RATE: Change the rate used to send multicast frames
include/uapi/linux/nl80211.h:3040: * @NL80211_KEYTYPE_GROUP: Group (broadcast/multicast) key
include/uapi/linux/nl80211.h:3074: *	multicast key
include/uapi/linux/netlink.h:39:       	__u32		nl_groups;	/* multicast groups mask */
include/uapi/linux/rtnetlink.h:542:/* RTnetlink multicast groups - backwards compatibility for userspace */
include/uapi/linux/rtnetlink.h:564:/* RTnetlink multicast groups */
include/uapi/linux/if_tun.h:102:#define TUN_FLT_ALLMULTI 0x0001 /* Accept all multicast packets */
include/uapi/linux/mroute.h:23:#define MRT_ADD_MFC	(MRT_BASE+4)	/* Add a multicast forwarding entry	*/
include/uapi/linux/mroute.h:24:#define MRT_DEL_MFC	(MRT_BASE+5)	/* Delete a multicast forwarding entry	*/
include/uapi/linux/mroute.h:25:#define MRT_VERSION	(MRT_BASE+6)	/* Get the kernel multicast version	*/
include/uapi/linux/if_bridge.h:132:/* Bridge multicast database attributes
include/uapi/linux/wireless.h:120: *	- Support for unicast and multicast power saving
include/uapi/linux/wireless.h:293:/* Power saving stuff (power management, unicast and multicast) */
include/uapi/linux/wireless.h:498:#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
include/uapi/linux/wireless.h:835:	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
include/uapi/linux/in6.h:60:	/* IPv6 multicast address of group */
include/uapi/linux/mroute6.h:23:#define MRT6_ADD_MFC	(MRT6_BASE+4)	/* Add a multicast forwarding entry	*/
include/uapi/linux/mroute6.h:24:#define MRT6_DEL_MFC	(MRT6_BASE+5)	/* Delete a multicast forwarding entry	*/
include/uapi/linux/mroute6.h:25:#define MRT6_VERSION	(MRT6_BASE+6)	/* Get the kernel multicast version	*/
include/uapi/linux/mroute6.h:122: * Structure used to communicate from kernel to multicast router.
include/uapi/linux/ip_vs.h:270:	/* multicast interface name */
include/uapi/linux/ip_vs.h:400:	IPVS_DAEMON_ATTR_MCAST_IFN,	/* multicast interface name */
include/uapi/linux/in.h:151:/* Request struct for multicast socket ops */
include/uapi/linux/in.h:154:	struct in_addr imr_multiaddr;	/* IP multicast address of group */
include/uapi/linux/in.h:159:	struct in_addr	imr_multiaddr;		/* IP multicast address of group */
include/uapi/linux/in.h:195:	struct __kernel_sockaddr_storage gf_group;	/* multicast address */
include/rdma/rdma_cm_ib.h:51:/* Global qkey for UDP QPs and multicast groups. */
include/rdma/ib_sa.h:326:					    struct ib_sa_multicast *multicast);
include/rdma/ib_sa.h:331: * ib_sa_join_multicast - Initiates a join request to the specified multicast
include/rdma/ib_sa.h:334: * @device: Device associated with the multicast group.
include/rdma/ib_sa.h:335: * @port_num: Port on the specified device to associate with the multicast
include/rdma/ib_sa.h:337: * @rec: SA multicast member record specifying group attributes.
include/rdma/ib_sa.h:344: * This call initiates a multicast join request with the SA for the specified
include/rdma/ib_sa.h:345: * multicast group.  If the join operation is started successfully, it returns
include/rdma/ib_sa.h:346: * an ib_sa_multicast structure that is used to track the multicast operation.
include/rdma/ib_sa.h:355: * -ENETRESET: Indicates that an fatal error has occurred on the multicast
include/rdma/ib_sa.h:364:								    *multicast),
include/rdma/ib_sa.h:368: * ib_free_multicast - Frees the multicast tracking structure, and releases
include/rdma/ib_sa.h:369: *    any reference on the multicast group.
include/rdma/ib_sa.h:370: * @multicast: Multicast tracking structure allocated by ib_join_multicast.
include/rdma/ib_sa.h:372: * This call blocks until the multicast identifier is destroyed.  It may
include/rdma/ib_sa.h:373: * not be called from within the multicast callback; however, returning a non-
include/rdma/ib_sa.h:374: * zero value from the callback will result in destroying the multicast
include/rdma/ib_sa.h:377:void ib_sa_free_multicast(struct ib_sa_multicast *multicast);
include/rdma/ib_sa.h:380: * ib_get_mcmember_rec - Looks up a multicast member record by its MGID and
include/rdma/ib_sa.h:382: * @device: Device associated with the multicast group.
include/rdma/ib_sa.h:383: * @port_num: Port on the specified device to associate with the multicast
include/rdma/ib_sa.h:385: * @mgid: MGID of multicast group.
include/rdma/ib_sa.h:386: * @rec: Location to copy SA multicast member record.
include/rdma/ib_sa.h:393: * an SA multicast member record.
include/rdma/ib_verbs.h:1105:	/* default unicast and multicast rule -
include/rdma/ib_verbs.h:1109:	/* default multicast rule -
include/rdma/ib_verbs.h:1110:	 * receive all Eth multicast traffic which isn't steered to any QP
include/rdma/ib_verbs.h:2388: * ib_attach_mcast - Attaches the specified QP to a multicast group.
include/rdma/ib_verbs.h:2389: * @qp: QP to attach to the multicast group.  The QP must be type
include/rdma/ib_verbs.h:2394: * In order to send and receive multicast packets, subnet
include/rdma/ib_verbs.h:2395: * administration must have created the multicast group and configured
include/rdma/ib_verbs.h:2397: * QP must also be a member of the multicast group.
include/rdma/ib_verbs.h:2402: * ib_detach_mcast - Detaches the specified QP from a multicast group.
include/rdma/ib_verbs.h:2403: * @qp: QP to detach from the multicast group.
include/rdma/rdma_cm.h:326: * rdma_join_multicast - Join the multicast group specified by the given
include/rdma/rdma_cm.h:331: * to the user through the private_data pointer in multicast events.
include/rdma/rdma_cm.h:337: * rdma_leave_multicast - Leave the multicast group specified by the given
include/scsi/libfcoe.h:95: * @sol_time:	   time when a multicast solicitation was last sent.
include/linux/mlx4/cmd.h:120:	/* multicast commands */
include/linux/if_macvlan.h:64:				    bool multicast)
include/linux/if_macvlan.h:73:		if (multicast)
include/linux/if_macvlan.h:88:			     bool multicast);
include/linux/etherdevice.h:101: * is_multicast_ether_addr - Determine if the Ethernet address is a multicast.
include/linux/etherdevice.h:104: * Return true if the address is a multicast address.
include/linux/etherdevice.h:105: * By definition the broadcast address is also a multicast address.
include/linux/etherdevice.h:154: * a multicast address, and is not FF:FF:FF:FF:FF:FF.
include/linux/etherdevice.h:162:	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
include/linux/etherdevice.h:171: * Generate a random Ethernet address (MAC) that is not multicast
include/linux/etherdevice.h:177:	addr[0] &= 0xfe;	/* clear multicast bit */
include/linux/genl_magic_func.h:257: * Define the genl_family, multicast groups,				{{{1
include/linux/genl_magic_func.h:273: * Magic: define multicast groups
include/linux/genl_magic_func.h:274: * Magic: define multicast group registration helper
include/linux/netdevice.h.orig:172:	unsigned long	multicast;
include/linux/netdevice.h.orig:795: *	changes to configuration when multicast or promiscious is enabled.
include/linux/netdevice.h.orig:2943:/* Functions used for multicast addresses handling */
include/linux/netdevice.h.orig:2955:/* Functions used for secondary unicast and multicast support */
include/linux/uwb.h:218: * @is_multicast:   true iff multicast
include/linux/if_vlan.h:89: *	@rx_multicast: number of received multicast packets
include/linux/fsl/bestcomm/fec.h:29:#define BCOM_FEC_RX_BD_MC	0x00400000ul	/* DA is multicast and not broadcast */
include/linux/inetdevice.h:29:	struct ip_mc_list __rcu	*mc_list;	/* IP multicast filter chain    */
include/linux/netdevice.h:172:	unsigned long	multicast;
include/linux/netdevice.h:795: *	changes to configuration when multicast or promiscious is enabled.
include/linux/netdevice.h:2944:/* Functions used for multicast addresses handling */
include/linux/netdevice.h:2956:/* Functions used for secondary unicast and multicast support */
Binary file vmlinux.o matches
usr/SOEM1.3.0/oshw/rtk/lw_mac/lw_emac.c:75:   uint32_t hashlo;           /* multicast hash table low */
usr/SOEM1.3.0/oshw/rtk/lw_mac/lw_emac.c:76:   uint32_t hashhi;           /* multicast hash table high */
usr/SOEM1.3.0/oshw/win32/wpcap/Include/Packet32.h:281:  the list of the multicast groups defined on it, and so on.
usr/SOEM1.3.0/oshw/win32/wpcap/Include/pcap/sll.h:49: *		LINUX_SLL_MULTICAST	packet was multicast
usr/SOEM1.3.0/oshw/win32/wpcap/Include/pcap/pcap.h:200:       u_long  multicast;         /* multicast packets received   */
usr/SOEM1.3.0_Joao_Modified/oshw/rtk/lw_mac/lw_emac.c:75:   uint32_t hashlo;           /* multicast hash table low */
usr/SOEM1.3.0_Joao_Modified/oshw/rtk/lw_mac/lw_emac.c:76:   uint32_t hashhi;           /* multicast hash table high */
usr/SOEM1.3.0_Joao_Modified/oshw/win32/wpcap/Include/Packet32.h:281:  the list of the multicast groups defined on it, and so on.
usr/SOEM1.3.0_Joao_Modified/oshw/win32/wpcap/Include/pcap/sll.h:49: *		LINUX_SLL_MULTICAST	packet was multicast
usr/SOEM1.3.0_Joao_Modified/oshw/win32/wpcap/Include/pcap/pcap.h:200:       u_long  multicast;         /* multicast packets received   */
sound/core/seq/seq_clientmgr.c:772:/* multicast - not supported yet */
sound/core/seq/seq_clientmgr.c:776:	snd_printd("seq: multicast not supported yet.\n");
Binary file .git/index matches
Binary file .git/objects/pack/pack-57a717f9bd849ea51fe2b615402206f76e7e1499.pack matches
fs/quota/netlink.c:19:	 * Needed due to multicast group ID abuse - old code assumed
fs/quota/netlink.c:20:	 * the family ID was also a valid multicast group ID (which
net/llc/llc_sap.c:383: * 	llc_sap_mcast - Deliver multicast PDU's to all matching datagram sockets.
net/llc/llc_proc.c:139:	/* FIXME: check if the address is multicast */
net/llc/af_llc.c:361:		 * FIXME: check if the address is multicast,
net/ipv4/tcp_ipv4.c:1464:	/* Never answer to SYNs send to broadcast or multicast */
net/ipv4/.igmp.o.cmd:8:    $(wildcard include/config/ip/multicast.h) \
net/ipv4/route.c:1844:	   hardware multicast filters :-( As result the host on multicasting
net/ipv4/route.c:1847:	   Really, provided software IP multicast filter is organized
net/ipv4/route.c:1850:	   Note, that multicast routers are not affected, because
net/ipv4/route.c:1923:		/* If multicast route do not exist use
net/ipv4/route.c:2059:			   because we are not allowed to build multicast path
net/ipv4/tcp.c:123: *		Alan Cox	:	No connect to multicast.
net/ipv4/ip_sockglue.c:251:   sent to multicast group to reach destination designated router.
net/ipv4/icmp.c:480: *			MUST NOT reply to a multicast/broadcast IP address.
net/ipv4/icmp.c:481: *			MUST NOT reply to a multicast/broadcast MAC address.
net/ipv4/icmp.c:515:	 *	No replies to physical multicast/broadcast
net/ipv4/icmp.c:975:		 *	  discarded if to broadcast/multicast.
net/ipv4/.ip_output.o.cmd:12:    $(wildcard include/config/ip/multicast.h) \
net/ipv4/ip_gre.c:342:   over the Internet, provided multicast routing is tuned.
net/ipv4/ip_tunnel_core.c:179:	tot->multicast = dev->stats.multicast;
net/ipv4/devinet.c:860:	int rc = -1;	/* Something else, probably a multicast. */
net/ipv4/ipmr.c:2: *	IP multicast routing support for mrouted 3.6/3.8
net/ipv4/ipmr.c:19: *	SVR Anand		:	Fixed several multicast bugs and problems.
net/ipv4/ipmr.c:880: *	Allocate a multicast cache entry
net/ipv4/ipmr.c:1201: *	Close the multicast socket, and clear the vif tables etc
net/ipv4/ipmr.c:1431: *	Getsock opt support for the multicast routing system.
net/ipv4/ipmr.c:1479: *	The IP multicast ioctl support routines.
net/ipv4/ipmr.c:1644: *	important for multicast video.
net/ipv4/ipmr.c:1838:			 * multicast applications WILL NOT work for
net/ipv4/ipmr.c:1839:			 * (S,G), which have default multicast route pointing
net/ipv4/ipmr.c:2053:	 * a. packet is really sent to a multicast group
net/ipv4/ipmr.c:2413: *	The /proc interfaces to multicast routing :
net/ipv4/ipmr.c:2700: *	Setup for IP multicast routing
net/ipv4/af_inet.c:487:	 *      would be illegal to use them (multicast/broadcast) in
net/ipv4/af_inet.c:1796:	 *	Initialise the multicast router
net/ipv4/.af_inet.o.cmd:8:    $(wildcard include/config/ip/multicast.h) \
net/ipv4/netfilter/ipt_CLUSTERIP.c:356:	/* despite being received via linklayer multicast, this is
net/ipv4/netfilter/ipt_ULOG.c:16: *   The parameter specifies how big the buffer for each netlink multicast
net/ipv4/netfilter/Kconfig:173:	  daemon using netlink multicast sockets; unlike the LOG target
net/ipv4/igmp.c:25: *		Alan Cox	:	Minor tweaks ready for multicast routing
net/ipv4/igmp.c:43: *					to identify the multicast router version
net/ipv4/igmp.c:1053:	   We will get multicast token leakage, when IFF_MULTICAST
net/ipv4/igmp.c:1301: *	A socket has joined a multicast group on device dev.
net/ipv4/igmp.c:1383: *	A socket has left a multicast group on device dev
net/ipv4/igmp.c:1666: * Add multicast single-source filter to the interface list
net/ipv4/igmp.c:1772: * Add multicast source filter list to the interface list
net/ipv4/igmp.c:1864: * Join a multicast group
net/ipv4/igmp.c:2327: * check if a multicast source filter allows delivery for a given <src,dst,intf>
net/ipv4/arp.c:805: *	Check for bad requests for 127.x.x.x and requests for multicast
net/ipv4/ip_tunnel.c:426:		tunnel->dev->stats.multicast++;
net/ipv4/ip_forward.c:13: *		Dave Gregorich	:	NULL ip_rt_put fix for multicast
net/ipv4/udp.c:1821:/* We can only early demux multicast if there is a single matching socket.
net/ipv4/ip_input.c:61: *		Alan Cox	:	Cleaned up multicast handlers.
net/ipv4/ip_input.c:85: *		Alan Cox	:	Fixed multicast (by popular demand 8))
net/ipv4/Kconfig:203:	  tunneling" above). In addition, GRE allows multicast redistribution
net/ipv4/Kconfig:213:	  to do that, say Y here and to "IP multicast routing" below.
net/ipv4/Kconfig:216:	bool "IP: multicast routing"
net/ipv4/Kconfig:227:	bool "IP: multicast policy routing"
net/ipv4/Kconfig:231:	  Normally, a multicast router runs a userspace daemon and decides
net/ipv4/Kconfig:232:	  what to do with a multicast packet based on the source and
net/ipv4/Kconfig:233:	  destination addresses. If you say Y here, the multicast router
net/ipv4/Kconfig:245:	  Multicast) version 1. This multicast routing protocol is used widely
net/8021q/vlan_dev.c:702:			stats->multicast	+= rxmulticast;
net/8021q/vlanproc.c:294:	seq_printf(seq, fmt64, "Broadcast/Multicast Rcvd", stats->multicast);
Binary file net/bluetooth/bnep/bnep.o matches
Binary file net/bluetooth/bnep/core.o matches
net/bluetooth/bnep/core.c:176:		/* Add address ranges to the multicast hash */
net/bluetooth/bnep/core.c:693:	strcat(flt, "multicast");
net/bluetooth/bnep/Kconfig:17:	  This option enables the multicast filter support for BNEP.
net/irda/irlan/irlan_common.c:383:	/* Open broadcast and multicast filter by default */
net/irda/irlan/irlan_common.c:826: *    Make IrLAN provider accept ethernet frames addressed to the multicast
net/irda/irlan/irlan_eth.c:327:		IRDA_DEBUG(4, "%s(), Setting multicast filter\n", __func__);
net/irda/irlan/irlan_eth.c:332:		IRDA_DEBUG(4, "%s(), Setting multicast filter\n", __func__);
net/irda/irlan/irlan_eth.c:338:		IRDA_DEBUG(4, "%s(), Clearing multicast filter\n", __func__);
net/atm/lec.h:86:						 * With LANEv2 it is possible that BUS (or a special multicast server)
net/atm/lec.c:557:	 * by default, all multicast frames arrive over the bus.
net/atm/lec.c:558:	 * eventually support selective multicast service
net/atm/lec.c:1738:		case 2:	/* LANE2 wants arp for multicast addresses */
net/sctp/input.c:162:	 * unicast address.  In other words, IP multicast addresses and
net/sctp/sm_make_chunk.c:3033:	 * or multicast address.
net/wireless/nl80211.c:50:/* multicast groups */
net/wireless/rdev-ops.h:114:		     bool multicast)
net/wireless/rdev-ops.h:118:				   unicast, multicast);
net/wireless/rdev-ops.h:120:					  unicast, multicast);
net/wireless/trace.h:438:		 bool unicast, bool multicast),
net/wireless/trace.h:439:	TP_ARGS(wiphy, netdev, key_index, unicast, multicast),
net/wireless/trace.h:445:		__field(bool, multicast)
net/wireless/trace.h:452:		__entry->multicast = multicast;
net/wireless/trace.h:454:	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", key index: %u, unicast: %s, multicast: %s",
net/wireless/trace.h:457:		  BOOL_TO_STR(__entry->multicast))
net/wimax/op-msg.c:283:	d_printf(1, dev, "CTX: genl multicast done\n");
net/l2tp/l2tp_ip6.c:280:	/* L2TP is point-point, not multicast */
net/ieee802154/6lowpan.h:100:/* multicast address */
net/ieee802154/6lowpan.h:103:/* check whether the 112-bit gid of the multicast address is mappable to: */
net/ieee802154/6lowpan_iphc.c:64: * destination address(non-multicast).
net/ieee802154/6lowpan_iphc.c:146: * based address(non-multicast).
net/ieee802154/6lowpan_iphc.c:209:/* Uncompress function for multicast destination address,
net/ieee802154/6lowpan_iphc.c:260:	raw_dump_inline(NULL, "Reconstructed ipv6 multicast addr is",
net/ieee802154/6lowpan_iphc.c:740:		pr_debug("destination address is multicast: ");
net/batman-adv/bridge_loop_avoidance.c:1584:	/* check if it is a multicast/broadcast frame */
net/batman-adv/soft-interface.c:145: * multicast listeners for instance.
net/bridge/br_input.c:118:		br->dev->stats.multicast++;
net/bridge/br_multicast.c:2: * Bridge multicast support.
net/bridge/br_multicast.c:567:			br_warn(br, "Cannot rehash multicast "
net/bridge/br_multicast.c:1184:	/* RFC2236+RFC3376 (IGMPv2+IGMPv3) require the multicast link layer
net/bridge/br_multicast.c:1276:	/* RFC2710+RFC3810 (MLDv1+MLDv2) require the multicast link layer
net/bridge/br_private.h:34:/* Control of forwarding link local multicast */
net/bridge/netfilter/ebt_ulog.c:16: *   The parameter specifies how big the buffer for each netlink multicast
net/bridge/netfilter/Kconfig:119:	  the generic networking code): broadcast, multicast,
net/bridge/netfilter/Kconfig:205:	  logging daemon using netlink multicast sockets. This differs
net/bridge/netfilter/Kconfig:208:	  netlink multicast sockets are used instead of the syslog.
net/bridge/Kconfig:43:	  forward multicast traffic based on IGMP/MLD traffic received from
net/tipc/name_table.c:609: * tipc_nametbl_mc_translate - find multicast destinations
net/tipc/name_table.c:611: * Creates list of all local ports that overlap the given multicast address;
net/tipc/bcast.c:73: * large local variables within multicast routines.  Concurrent access is
net/tipc/bcast.c:888:				pr_warn("Incomplete multicast delivery, no memory\n");
net/tipc/port.c:90: * tipc_multicast - send a multicast message to local and remote destinations
net/tipc/port.c:106:	/* Create multicast message */
net/tipc/port.c:120:	/* Figure out where to send multicast message */
net/tipc/port.c:151: * tipc_port_recv_mcast - deliver multicast message to all destination ports
net/tipc/port.c:188:				pr_warn("Unable to deliver multicast message(s)\n");
net/tipc/socket.c:1534:	 * Reject connection attempt using multicast address
net/tipc/bearer.c:526: * ignores packets sent using interface multicast, and traffic sent to other
net/mac80211/wpa.c:129:		 * group keys and only the AP is sending real multicast
net/mac80211/wpa.c:168:	 * In some cases the key can be unset - e.g. a multicast packet, in
net/mac80211/rx.c:541:		 *	frames with a broadcast/multicast address in the
net/mac80211/rx.c:1403:	 * When selecting a key, we have to distinguish between multicast
net/mac80211/rx.c:1410:	 * Note that in a regular BSS, multicast frames are sent by the
net/mac80211/rx.c:1423:	 * addressed to us nor a multicast frame.
net/mac80211/rx.c:1456:		/* Broadcast/multicast robust management frame / BIP */
net/mac80211/rx.c:1536:		/* check per-station GTK first, if multicast packet */
net/mac80211/rx.c:1952:			 * send multicast frames both to higher layers in
net/mac80211/rx.c:1957:				net_info_ratelimited("%s: failed to clone multicast frame\n",
net/mac80211/rx.c:3097:	int multicast = is_multicast_ether_addr(hdr->addr1);
net/mac80211/rx.c:3103:		if (!multicast &&
net/mac80211/rx.c:3121:		} else if (!multicast &&
net/mac80211/rx.c:3137:		if (!multicast &&
net/mac80211/rx.c:3157:			if (!multicast &&
net/mac80211/rx.c:3180:		    !multicast)
net/mac80211/mesh_plink.c:1094:			"Mesh plink: ignore frame from multicast address\n");
Binary file net/mac80211/rx.o matches
Binary file net/mac80211/mac80211.o matches
net/mac80211/status.c:724:		 * with a multicast address in the address 1 field of type Data
net/mac80211/mesh.h:164:/* Recent multicast cache */
net/mac80211/mesh.h:177: * The Recent Multicast Cache keeps track of the latest multicast frames that
net/mac80211/mesh.h:178: * have been received by a mesh interface and discards received multicast frames
net/mac80211/ieee80211_i.h:37:/* Maximum number of broadcast/multicast frames to buffer when some of the
net/mac80211/ieee80211_i.h:41:/* Maximum number of frames buffered to all STAs, including multicast frames.
net/mac80211/ieee80211_i.h:183: *	(incl. multicast frames)
net/mac80211/ieee80211_i.h:277:	atomic_t num_mcast_sta; /* number of stations receiving multicast */
net/mac80211/ieee80211_i.h:297:	__u32 fwded_mcast;		/* Mesh forwarded multicast frames */
net/mac80211/ieee80211_i.h:650: * @IEEE80211_SDATA_ALLMULTI: interface wants all multicast packets
net/mac80211/ieee80211_i.h:654: *	associated stations and deliver multicast frames both
net/mac80211/ieee80211_i.h:1021:	/* protects the aggregated multicast list and filter calls */
net/mac80211/ieee80211_i.h:1027:	/* aggregated multicast list */
net/mac80211/ieee80211_i.h:1204:				* multicast packets for power saving stations
net/mac80211/trace.h:450:		 u64 multicast),
net/mac80211/trace.h:452:	TP_ARGS(local, changed_flags, total_flags, multicast),
net/mac80211/trace.h:458:		__field(u64, multicast)
net/mac80211/trace.h:465:		__entry->multicast = multicast;
net/mac80211/rx.c.orig:541:		 *	frames with a broadcast/multicast address in the
net/mac80211/rx.c.orig:1403:	 * When selecting a key, we have to distinguish between multicast
net/mac80211/rx.c.orig:1410:	 * Note that in a regular BSS, multicast frames are sent by the
net/mac80211/rx.c.orig:1423:	 * addressed to us nor a multicast frame.
net/mac80211/rx.c.orig:1456:		/* Broadcast/multicast robust management frame / BIP */
net/mac80211/rx.c.orig:1536:		/* check per-station GTK first, if multicast packet */
net/mac80211/rx.c.orig:1952:			 * send multicast frames both to higher layers in
net/mac80211/rx.c.orig:1957:				net_info_ratelimited("%s: failed to clone multicast frame\n",
net/mac80211/rx.c.orig:3097:	int multicast = is_multicast_ether_addr(hdr->addr1);
net/mac80211/rx.c.orig:3103:		if (!multicast &&
net/mac80211/rx.c.orig:3121:		} else if (!multicast &&
net/mac80211/rx.c.orig:3137:		if (!multicast &&
net/mac80211/rx.c.orig:3157:			if (!multicast &&
net/mac80211/rx.c.orig:3180:		    !multicast)
net/mac80211/tx.c:324:		 * No associated STAs - no need to send multicast
net/mac80211/tx.c:392:	 * broadcast/multicast frame
net/mac80211/tx.c:805:	 * counter.  QoS data frames with a multicast destination
net/mac80211/tx.c:1818:	bool multicast;
net/mac80211/tx.c:2032:	 * if it is a multicast address (which can only happen
net/mac80211/tx.c:2035:	multicast = is_multicast_ether_addr(hdr.addr1);
net/mac80211/tx.c:2036:	if (!multicast) {
net/mac80211/tx.c:2059:		     !multicast && !authorized &&
net/mac80211/tx.c:2072:	if (unlikely(!multicast && skb->sk &&
net/mac80211/tx.c:2905:			/* more buffered multicast/broadcast frames ==> set
net/mac80211/driver-ops.h:248:					u64 multicast)
net/mac80211/driver-ops.h:253:				   multicast);
net/mac80211/driver-ops.h:255:				     multicast);
net/mac80211/mesh.c:202: * mesh_rmc_check - Check frame in recent multicast cache and add if absent.
net/mac80211/mlme.c:1793:	 * at that time. But multicast frames (and hence also beacons) must
net/ipv6/ipv6_sockglue.c:22: *		- added multicast source filtering API for MLDv2
net/ipv6/addrconf.c:404:	/* Join interface-local all-node multicast group */
net/ipv6/addrconf.c:407:	/* Join all-node multicast group */
net/ipv6/addrconf.c:410:	/* Join all-router multicast group if forwarding is set */
net/ipv6/addrconf.c:1340:		 *  - multicast and link-local destination address,
net/ipv6/addrconf.c:1370:			 *  - In any case, anycast addresses, multicast
net/ipv6/addrconf.c:1383:					       "ADDRCONF: unspecified / multicast address "
net/ipv6/addrconf.c:1687:/* Join to solicited addr multicast group.
net/ipv6/addrconf.c:2030:/* Create "default" multicast route to the interface */
net/ipv6/addrconf.c:2061:	/* Add default multicast route */
net/ipv6/addrconf.c:3091:	/* Step 5: Discard multicast list */
net/ipv6/addrconf.c:4091:		/* multicast address */
net/ipv6/route.c:1800:		net_dbg_ratelimited("rt6_do_redirect: destination address is multicast\n");
net/ipv6/exthdrs.c:80:	case 3: /* Send ICMP if not a multicast address and drop packet */
net/ipv6/icmp.c:446:	 *	We check unspecified / multicast addresses here,
net/ipv6/ndisc.c:714:		ND_PRINTK(2, warn, "NS: multicast target address\n");
net/ipv6/ndisc.c:720:	 * DAD has to be destined for solicited node multicast address.
net/ipv6/ndisc.c:870:		ND_PRINTK(2, warn, "NA: target address is multicast\n");
net/ipv6/mcast.c:126: *	socket join on multicast group
net/ipv6/mcast.c:224: *	socket leave on multicast group
net/ipv6/mcast.c:851: *	device multicast group inc (add if not found)
net/ipv6/mcast.c:925: *	device multicast group del
net/ipv6/mcast.c:1060: *	IGMP handling (alias multicast ICMPv6 messages)
net/ipv6/mcast.c:2159: * Add multicast single-source filter to the interface list
net/ipv6/mcast.c:2263: * Add multicast source filter list to the interface list
net/ipv6/mcast.c:2453:	/* Install multicast list, except for all-nodes (already installed) */
net/ipv6/mcast.c:2472:	/* Withdraw multicast list */
net/ipv6/mcast.c:2493:	/* Install multicast list, except for all-nodes (already installed) */
net/ipv6/ip6_input.c:128:	 * multicast.  Packets with interface-local scope received
net/ipv6/ip6_input.c:138:	 * Nodes must not originate a packet to a multicast address whose scope
net/ipv6/ip6_input.c:297:	 *      IPv6 multicast router mode is now supported ;)
net/ipv6/ip6mr.c:2: *	Linux IPv6 multicast routing support for BSD pim6sd
net/ipv6/ip6mr.c:381: *	The /proc interfaces to multicast routing /proc/ip6_mr_cache /proc/ip6_mr_vif
net/ipv6/ip6mr.c:1072: *	Allocate a multicast cache entry
net/ipv6/ip6mr.c:1209:	 *	Deliver to user space multicast routing algorithms
net/ipv6/ip6mr.c:1356: *	Setup for IP multicast routing
net/ipv6/ip6mr.c:1536: *	Close the multicast socket, and clear the vif tables etc
net/ipv6/ip6mr.c:1801: *	Getsock opt support for the multicast routing system.
net/ipv6/ip6mr.c:1847: *	The IP multicast ioctl support routines.
net/ipv6/netfilter/ip6t_hbh.c:33: *	3	-> Send ICMP if not a multicast address and drop packet
net/ipv6/ip6_output.c:80:			/* Do not check for IFF_ALLMULTI; multicast routing
net/ipv6/addrconf_core.c:44:		/* multicast */
Binary file net/ipv6/ipv6.o matches
Binary file net/ipv6/built-in.o matches
net/ipv6/Kconfig:208:	  tunneling" above). In addition, GRE allows multicast redistribution
net/ipv6/Kconfig:234:	bool "IPv6: multicast routing"
net/ipv6/Kconfig:237:	  Experimental support for IPv6 multicast forwarding.
net/ipv6/Kconfig:241:	bool "IPv6: multicast policy routing"
net/ipv6/Kconfig:245:	  Normally, a multicast router runs a userspace daemon and decides
net/ipv6/Kconfig:246:	  what to do with a multicast packet based on the source and
net/ipv6/Kconfig:247:	  destination addresses. If you say Y here, the multicast router
net/ipv6/Kconfig:258:	  Support for IPv6 PIM multicast routing protocol PIM-SMv2.
Binary file net/ipv6/addrconf.o matches
net/802/hippi.c:174:	/* Never send broadcast/multicast ARP messages */
net/802/hippi.c:211:	 * HIPPI doesn't support broadcast+multicast and we only use
net/dccp/ipv4.c:604:	/* Never answer to DCCP_PKT_REQUESTs send to broadcast or multicast */
net/netfilter/xt_cluster.c:100:	 * this, your cluster nodes can reply ARP request using a multicast MAC
net/netfilter/xt_cluster.c:102:	 * cluster nodes with the same multicast MAC address. Using a multicast
net/netfilter/xt_cluster.c:106:	 * Unfortunately, if you use the multicast MAC address, the link layer
net/netfilter/ipvs/ip_vs_sync.c:23: *              through multicast
net/netfilter/ipvs/ip_vs_sync.c:59:#define IP_VS_SYNC_GROUP 0xe0000051    /* multicast addr - 224.0.0.81 */
net/netfilter/ipvs/ip_vs_sync.c:60:#define IP_VS_SYNC_PORT  8848          /* multicast port */
net/netfilter/ipvs/ip_vs_sync.c:929: *  Process received multicast message for Version 0
net/netfilter/ipvs/ip_vs_sync.c:1178: *      Process received multicast message and create the corresponding
net/netfilter/ipvs/ip_vs_sync.c:1363: *      Join a multicast group.
net/netfilter/ipvs/ip_vs_sync.c:1364: *      the group is specified by a class D multicast address 224.0.0.0/8
net/netfilter/ipvs/ip_vs_sync.c:1408:		       "multicast interface.\n");
net/netfilter/ipvs/ip_vs_sync.c:1413:	/* Now bind the socket with the address of multicast interface */
net/netfilter/ipvs/ip_vs_sync.c:1422: *      Set up sending multicast socket over UDP
net/netfilter/ipvs/ip_vs_sync.c:1427:	/* multicast addr */
net/netfilter/ipvs/ip_vs_sync.c:1469:		pr_err("Error connecting to the multicast addr\n");
net/netfilter/ipvs/ip_vs_sync.c:1482: *      Set up receiving multicast socket over UDP
net/netfilter/ipvs/ip_vs_sync.c:1487:	/* multicast addr */
net/netfilter/ipvs/ip_vs_sync.c:1517:		pr_err("Error binding to the multicast addr\n");
net/netfilter/ipvs/ip_vs_sync.c:1521:	/* join the multicast group */
net/netfilter/ipvs/ip_vs_sync.c:1526:		pr_err("Error joining to the multicast group\n");
net/netfilter/ipvs/ip_vs_sync.c:1670:	/* release the sending multicast socket */
net/netfilter/ipvs/ip_vs_sync.c:1707:	/* release the sending multicast socket */
net/netfilter/nf_conntrack_h323_types.c:783:	{FNAME("multicast") NUL, FIXD, 0, 0, SKIP, 0, NULL},
net/core/net-procfs.c:90:		   stats->rx_compressed, stats->multicast,
net/core/net-procfs.c:111:			      "compressed multicast|bytes    packets errs "
net/core/dev.c.orig:37: *					you start doing multicast video 8)
net/core/dev.c.orig:1290: *	function is invoked and then the multicast lists are loaded. Finally
net/core/dev.c.orig:5303: *	Add or remove reception of all multicast frames to a device. While the
net/core/dev.c.orig:5318: *	Upload unicast and multicast address lists to device and
net/core/dev.c.orig:5407:	 *	Load in the correct multicast list now the flags have changed.
net/core/dev.c.orig:5716:		 *	Flush the unicast and multicast chains
net/core/dev.c.orig:6738:	 *	Flush the unicast and multicast chains
net/core/dev.c:37: *					you start doing multicast video 8)
net/core/dev.c:1296: *	function is invoked and then the multicast lists are loaded. Finally
net/core/dev.c:5352: *	Add or remove reception of all multicast frames to a device. While the
net/core/dev.c:5367: *	Upload unicast and multicast address lists to device and
net/core/dev.c:5456:	 *	Load in the correct multicast list now the flags have changed.
net/core/dev.c:5765:		 *	Flush the unicast and multicast chains
net/core/dev.c:6787:	 *	Flush the unicast and multicast chains
Binary file net/core/net-sysfs.o matches
net/core/net-sysfs.c:437:NETSTAT_ENTRY(multicast);
net/core/dev_addr_lists.c:5: * This file contains functions for working with unicast, multicast and device
net/core/dev_addr_lists.c:552: *	dev_mc_add_excl - Add a global secondary multicast address
net/core/dev_addr_lists.c:593: *	dev_mc_add - Add a multicast address
net/core/dev_addr_lists.c:597: *	Add a multicast address to the device or increase
net/core/dev_addr_lists.c:607: *	dev_mc_add_global - Add a global multicast address
net/core/dev_addr_lists.c:611: *	Add a global multicast address to the device.
net/core/dev_addr_lists.c:634: *	dev_mc_del - Delete a multicast address.
net/core/dev_addr_lists.c:638: *	Release reference to a multicast address and remove it
net/core/dev_addr_lists.c:648: *	dev_mc_del_global - Delete a global multicast address.
net/core/dev_addr_lists.c:652: *	Release reference to a multicast address and remove it
net/core/dev_addr_lists.c:662: *	dev_mc_sync - Synchronize device's multicast list to another device
net/core/dev_addr_lists.c:690: *	dev_mc_sync_multiple - Synchronize device's multicast list to another
net/core/dev_addr_lists.c:743: *	dev_mc_flush - Flush multicast addresses
net/core/dev_addr_lists.c:746: *	Flush multicast addresses.
net/core/dev_addr_lists.c:757: *	dev_mc_flush - Init multicast address list
net/core/dev_addr_lists.c:760: *	Init multicast address list.
net/core/rtnetlink.c:764:	a->multicast = b->multicast;
Binary file net/core/net-procfs.o matches
Binary file net/core/built-in.o matches
net/appletalk/ddp.c:1321:	 * Don't route multicast, etc., packets, or packets sent to "this
net/netlink/af_netlink.c:2563: * netlink_change_ngroups - change number of multicast groups
net/netlink/af_netlink.c:2565: * This changes the number of multicast groups that are available
net/netlink/af_netlink.c:2839: * @group: destination multicast group or 0
net/netlink/genetlink.c:63: * Bitmap of multicast groups that are currently in use.
net/hsr/hsr_device.c:495:/* Default multicast address for HSR Supervision frames */
net/hsr/hsr_main.c:330:		 * another net (different multicast address). Ignore it.
net/hsr/hsr_main.c:413:				hsr_priv->dev->stats.multicast++;
Binary file net/built-in.o matches
Documentation/dvb/faq.txt:123:6. The dvb_net device doesn't give me any multicast packets
Documentation/dvb/faq.txt:125:	Check your routes if they include the multicast address range.
Documentation/infiniband/ipoib.txt:48:  In connected mode, the interface's UD QP is still used for multicast
Documentation/infiniband/ipoib.txt:86:  it is possible to get statistics about multicast groups from the
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:887:  The daemon and multicast transports provide a completely virtual
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:1139:  multicast enabled in the kernel and there must be a multicast-capable
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:1175:       ethn=mcast,ethernet address,multicast
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:1176:       address,multicast port,ttl
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:1186:  This is useful when your network does not support multicast, and
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:4329:  Harald Welte <laforge at gnumonks.org>  - Wrote the multicast
Documentation/kernel-docs.txt:191:       configuration, multicast.
Documentation/filesystems/proc.txt:1030: igmp6      IP multicast addresses, which this host joined (IPv6) 
Documentation/filesystems/proc.txt:1044: dev_mcast     the Layer2 multicast groups a device is listening too
Documentation/filesystems/proc.txt:1063: igmp          IP multicast addresses, which this host joined                  
Documentation/filesystems/proc.txt:1066: ip_mr_vifs    List of multicast virtual interfaces                            
Documentation/filesystems/proc.txt:1067: ip_mr_cache   List of multicast routing cache                                 
Documentation/filesystems/proc.txt:1075:   face |bytes    packets errs drop fifo frame compressed multicast|[... 
Documentation/connector/connector.txt:166:option.  To drop a multicast subscription, one should call the above socket
Documentation/networking/operstates.txt:144: netlink multicast signals this state
Documentation/networking/operstates.txt:148:-see how operstate and IFF_RUNNING is echoed via netlink multicast
Documentation/networking/ip-sysctl.txt:760:	TIMESTAMP requests sent to it via broadcast/multicast.
Documentation/networking/ip-sysctl.txt:817:	Change the maximum number of multicast groups we can subscribe to.
Documentation/networking/ip-sysctl.txt:865:	Do multicast routing. The kernel needs to be compiled with CONFIG_MROUTE
Documentation/networking/ip-sysctl.txt:866:	and a multicast routing daemon is required.
Documentation/networking/ip-sysctl.txt:867:	conf/all/mc_forwarding must also be set to TRUE to enable multicast
Documentation/networking/ip-sysctl.txt:1072:	via netlink before dropping back to multicast probes (see
Documentation/networking/ip-sysctl.txt:1385:	"The option MUST be included for multicast solicitations in order to
Documentation/networking/netlink_mmap.txt:147:- nm_group specified the destination multicast group of message
Documentation/networking/vxlan.txt:28:the multicast group 239.1.1.1 over eth1 to handle packets where
Documentation/networking/timestamping/timestamping.c:413:	/* set multicast group for outgoing packets */
Documentation/networking/timestamping/timestamping.c:421:		bail("set multicast");
Documentation/networking/timestamping/timestamping.c:423:	/* join multicast group, loop our own packet */
Documentation/networking/timestamping/timestamping.c:426:		bail("join multicast group");
Documentation/networking/timestamping/timestamping.c:430:		bail("loop multicast");
Documentation/networking/gianfar.txt:57:TSEC (and the extended hash table on the eTSEC) for multicast
Documentation/networking/gianfar.txt:60:multicast groups.
Documentation/networking/xfrm_sync.txt:76:A program needs to subscribe to multicast group XFRMNLGRP_AEVENTS
Documentation/networking/xfrm_sync.txt:102:at least one listener registered to listen to the multicast
drivers/thermal/thermal_core.c:1755:	/* send multicast genetlink message */
drivers/acpi/event.c:139:	/* send multicast genetlink message */
drivers/uwb/address.c:347:		dev_err(&rc->uwb_dev.dev, "refusing to set multicast "
drivers/net/macvlan.c:102:	/* Test to see if the specified multicast address is
drivers/net/macvlan.c:608:			stats->multicast	+= rx_multicast;
drivers/net/virtio_net.c:1143:	/* multicast list and count fill the end */
drivers/net/veth.c:191:/* fake multicast ability */
drivers/net/wireless/libertas/cfg.c:1490:				   bool multicast)
drivers/net/wireless/libertas/defs.h:127: *	Current version of MAC has a 32x6 multicast address buffer.
drivers/net/wireless/rtl818x/rtl8180/dev.c:846:				     u64 multicast)
drivers/net/wireless/rtl818x/rtl8180/dev.c:856:	if (*total_flags & FIF_ALLMULTI || multicast > 0)
drivers/net/wireless/rtl818x/rtl8187/dev.c:1305:				     u64 multicast)
drivers/net/wireless/rtl818x/rtl8187/dev.c:1315:	if (*total_flags & FIF_ALLMULTI || multicast > 0)
drivers/net/wireless/iwlegacy/4965-mac.c:6166:			unsigned int *total_flags, u64 multicast)
drivers/net/wireless/iwlegacy/4965-mac.c:6201:	 * Receiving all multicast frames is always enabled by the
drivers/net/wireless/iwlegacy/4965-mac.c:6203:	 * since we currently do not support programming multicast
drivers/net/wireless/iwlegacy/4965.h:175:			     unsigned int *total_flags, u64 multicast);
drivers/net/wireless/iwlegacy/3945-mac.c:3041:			unsigned int *total_flags, u64 multicast)
drivers/net/wireless/iwlegacy/3945-mac.c:3076:	 * Receiving all multicast frames is always enabled by the
drivers/net/wireless/iwlegacy/3945-mac.c:3078:	 * since we currently do not support programming multicast
drivers/net/wireless/iwlegacy/commands.h:1283: * Set this for unicast frames, but not broadcast/multicast. */
drivers/net/wireless/zd1211rw/zd_chip.h:444: * set. This is used for multicast handling, but for broadcasts (address
drivers/net/wireless/zd1211rw/zd_mac.c:309:	/* Wait after setting the multicast hash table and powering on
drivers/net/wireless/zd1211rw/zd_mac.c:672:	/* No ACK expected (multicast, etc.) */
drivers/net/wireless/zd1211rw/zd_mac.c:1173:	 * Send out buffered broad- and multicast frames.
drivers/net/wireless/zd1211rw/zd_mac.c:1238:			u64 multicast)
drivers/net/wireless/zd1211rw/zd_mac.c:1241:		.low = multicast,
drivers/net/wireless/zd1211rw/zd_mac.c:1242:		.high = multicast >> 32,
drivers/net/wireless/zd1211rw/zd_mac.c:1253:	 * If multicast parameter (as returned by zd_op_prepare_multicast)
drivers/net/wireless/zd1211rw/zd_mac.c:1256:	 * we will have some issue with IPv6 which uses multicast for link
drivers/net/wireless/adm8211.c:1344:				     u64 multicast)
drivers/net/wireless/adm8211.c:1351:	mc_filter[0] = multicast;
drivers/net/wireless/adm8211.c:1352:	mc_filter[1] = multicast >> 32;
drivers/net/wireless/adm8211.c:1361:	} else if (*total_flags & FIF_ALLMULTI || multicast == ~(0ULL)) {
drivers/net/wireless/rt2x00/rt2500usb.h:267: * DROP_MCAST: Drop multicast frames.
drivers/net/wireless/rt2x00/rt2x00dev.c:187:	 * Only AP mode interfaces do broad- and multicast buffering
drivers/net/wireless/rt2x00/rt2x00dev.c:193:	 * Send out buffered broad- and multicast frames
drivers/net/wireless/rt2x00/rt2x00dev.c:627:	/* 2. Maybe the AP wants to send multicast/broadcast data? */
drivers/net/wireless/rt2x00/rt2500pci.h:488: * DROP_MCAST: Drop multicast frames.
drivers/net/wireless/rt2x00/rt2x00.h:1426:				u64 multicast);
drivers/net/wireless/rt2x00/rt73usb.h:326: * DROP_MULTICAST: Drop multicast frames.
drivers/net/wireless/rt2x00/rt2500usb.c:1700:	 * multicast and broadcast traffic immediately instead of buffering it
drivers/net/wireless/rt2x00/rt2800lib.c:7484:	 * multicast and broadcast traffic immediately instead of buffering it
drivers/net/wireless/rt2x00/rt2x00mac.c:348:				u64 multicast)
drivers/net/wireless/rt2x00/rt73usb.c:2113:	 * multicast and broadcast traffic immediately instead of buffering it
drivers/net/wireless/rt2x00/rt2800usb.h:81: * MULTICAST: This is a multicast frame.
drivers/net/wireless/rt2x00/rt61pci.h:412: * DROP_MULTICAST: Drop multicast frames.
drivers/net/wireless/hostap/hostap_80211_rx.c:791:		 * even with broad/multicast targets (this is against IEEE
drivers/net/wireless/hostap/hostap_80211_rx.c:807:			/* This seems to be triggered by some (multicast?)
drivers/net/wireless/hostap/hostap_80211_rx.c:1072:			/* copy multicast frame both to the higher layers and
drivers/net/wireless/hostap/hostap_80211_rx.c:1078:				       "multicast frame\n", dev->name);
drivers/net/wireless/hostap/hostap_ap.c:2761:		/* broadcast/multicast frame - no AP related processing */
drivers/net/wireless/hostap/hostap_ap.c:3037:			 * broadcast/multicast in another BSS - drop */
drivers/net/wireless/hostap/hostap_80211_tx.c:174:		/* send broadcast and multicast frames to broadcast RA, if
drivers/net/wireless/hostap/hostap_wlan.h:776:			   * with RX of broad/multicast frames */
drivers/net/wireless/mwl8k.c:5039:	 * hardware multicast address filter.  At this point we don't
drivers/net/wireless/mwl8k.c:5092:				   u64 multicast)
drivers/net/wireless/mwl8k.c:5095:	struct mwl8k_cmd_pkt *cmd = (void *)(unsigned long)multicast;
drivers/net/wireless/mwl8k.c:5161:	 * a command packet that enables reception of all multicast
drivers/net/wireless/ti/wl1251/main.c:731:	/* update multicast filtering parameters */
drivers/net/wireless/ti/wl1251/main.c:757:				       unsigned int *total, u64 multicast)
drivers/net/wireless/ti/wl1251/main.c:759:	struct wl1251_filter_params *fp = (void *)(unsigned long)multicast;
drivers/net/wireless/ti/wl1251/main.c:786:		 * all multicast frames
drivers/net/wireless/ti/wlcore/init.c:452:	/* use the min basic rate for AP broadcast/multicast */
drivers/net/wireless/ti/wlcore/main.c:3053:	/* update multicast filtering parameters */
drivers/net/wireless/ti/wlcore/main.c:3078:				       unsigned int *total, u64 multicast)
drivers/net/wireless/ti/wlcore/main.c:3080:	struct wl1271_filter_params *fp = (void *)(unsigned long)multicast;
drivers/net/wireless/p54/main.c:394:				 u64 multicast)
drivers/net/wireless/p54/main.c:407:	if (changed_flags & FIF_ALLMULTI || multicast)
drivers/net/wireless/ath/wcn36xx/main.c:301:				     unsigned int *total, u64 multicast)
drivers/net/wireless/ath/wcn36xx/hal.h:725:	/* 0 for multicast */
drivers/net/wireless/ath/wcn36xx/hal.h:2234:	/* The sum of the transmit-directed byte count, transmit-multicast
drivers/net/wireless/ath/wcn36xx/hal.h:2822:	u8 multicast;
drivers/net/wireless/ath/ar5523/ar5523.c:1328:				    u64 multicast)
drivers/net/wireless/ath/ath9k/htc_drv_txrx.c:920:	/* calculate and install multicast filter */
drivers/net/wireless/ath/ath9k/htc_drv_main.c:1245:				       u64 multicast)
drivers/net/wireless/ath/ath9k/ar9003_phy.c:625:	 * feature, we switch it off; otherwise multicast search based on
drivers/net/wireless/ath/ath9k/main.c:1398:				   u64 multicast)
drivers/net/wireless/ath/ath9k/recv.c:103:	/* calculate and install multicast filter */
drivers/net/wireless/ath/ath9k/recv.c:358: * o always accept unicast, broadcast, and multicast traffic
drivers/net/wireless/ath/ath9k/recv.c:546:		 * Remain awake waiting for buffered broadcast/multicast
drivers/net/wireless/ath/ath9k/recv.c:547:		 * frames. If the last broadcast/multicast frame is not
drivers/net/wireless/ath/ath9k/recv.c:553:			"Received DTIM beacon indicating buffered broadcast/multicast frame(s)\n");
drivers/net/wireless/ath/ath9k/recv.c:586:		 * No more broadcast/multicast frames to be received at this
drivers/net/wireless/ath/ath9k/ar5008_phy.c:618:		 * multicast search based on MAC addr only will fail.
drivers/net/wireless/ath/carl9170/rx.c:560:	/* 2. Maybe the AP wants to send multicast/broadcast data? */
drivers/net/wireless/ath/carl9170/rx.c:669:	 * broadcast/multicast or unicast) we have to react quickly.
drivers/net/wireless/ath/carl9170/main.c:990:					 u64 multicast)
drivers/net/wireless/ath/carl9170/main.c:1009:		multicast = ~0ULL;
drivers/net/wireless/ath/carl9170/main.c:1011:	if (multicast != ar->cur_mc_hash)
drivers/net/wireless/ath/carl9170/main.c:1012:		WARN_ON(carl9170_update_multicast(ar, multicast));
drivers/net/wireless/ath/ath5k/mac80211-ops.c:350: * o always accept unicast, broadcast, and multicast traffic
drivers/net/wireless/ath/ath5k/mac80211-ops.c:351: * o multicast traffic for all BSSIDs will be enabled if mac80211
drivers/net/wireless/ath/ath5k/mac80211-ops.c:369:		       unsigned int *new_flags, u64 multicast)
drivers/net/wireless/ath/ath5k/mac80211-ops.c:382:	mfilt[0] = multicast;
drivers/net/wireless/ath/ath5k/mac80211-ops.c:383:	mfilt[1] = multicast >> 32;
drivers/net/wireless/ath/ath5k/mac80211-ops.c:391:	 * XXX: move unicast, bssid broadcasts and multicast to mac80211 */
drivers/net/wireless/ath/ath5k/mac80211-ops.c:471:	/* Set multicast bits */
drivers/net/wireless/ath/ath5k/pcu.c:459: * ath5k_hw_set_mcast_filter() - Set multicast filter
drivers/net/wireless/ath/ath5k/pcu.c:462: * @filter1: Higher 16bits of multicast filter
drivers/net/wireless/ath/ath5k/reg.h:1347:#define	AR5K_RX_FILTER_MCAST	0x00000002	/* Don't filter multicast frames */
drivers/net/wireless/ath/key.c:106:		 * for multicast frame decryption.
drivers/net/wireless/ath/ath6kl/txrx.c:1618:		vif->net_stats.multicast++;
drivers/net/wireless/ath/ath6kl/main.c:1170:	/* Enable multicast-all filter. */
drivers/net/wireless/ath/ath6kl/main.c:1192:	/* Enable/disable "multicast-all" filter*/
drivers/net/wireless/ath/ath6kl/main.c:1193:	ath6kl_dbg(ATH6KL_DBG_TRC, "%s multicast-all filter\n",
drivers/net/wireless/ath/ath6kl/main.c:1199:		ath6kl_warn("Failed to %s multicast-all receive\n",
drivers/net/wireless/ath/ath6kl/main.c:1224:				   "Removing %pM from multicast filter\n",
drivers/net/wireless/ath/ath6kl/main.c:1230:				ath6kl_warn("Failed to remove multicast filter:%pM\n",
drivers/net/wireless/ath/ath6kl/main.c:1262:			/* Set the multicast filter */
drivers/net/wireless/ath/ath6kl/main.c:1264:				   "Adding %pM to multicast filter list\n",
drivers/net/wireless/ath/ath6kl/main.c:1270:				ath6kl_warn("Failed to add multicast filter :%pM\n",
drivers/net/wireless/ath/ath6kl/core.h:105:	 * Allow all multicast in host awake mode.
drivers/net/wireless/ath/ath6kl/core.h:106:	 * Apply multicast filter in WOW mode.
drivers/net/wireless/ath/ath6kl/wmi.c:3231:		ath6kl_warn("invalid multicast filter address\n");
drivers/net/wireless/ath/ath6kl/cfg80211.c:1311:					   bool multicast)
drivers/net/wireless/ath/ath6kl/cfg80211.c:1344:	if (multicast)
drivers/net/wireless/ath/ath6kl/cfg80211.c:2005:	 * Setup multicast pattern for mDNS 224.0.0.251,
drivers/net/wireless/ath/ath6kl/cfg80211.c:2051:	 * Setup multicast pattern for mDNS 224.0.0.251,
drivers/net/wireless/ath/ath10k/wmi.h:1284:	 *   which peers belong to a given multicast group, so that if
drivers/net/wireless/ath/ath10k/wmi.h:1285:	 *   multicast->unicast conversion is enabled, the target can convert
drivers/net/wireless/ath/ath10k/wmi.h:1286:	 *   multicast tx frames to a series of unicast tx frames, to each
drivers/net/wireless/ath/ath10k/wmi.h:1287:	 *   peer within the multicast group.
drivers/net/wireless/ath/ath10k/wmi.h:1289:	 *   many multicast groups to provide storage for within its multicast
drivers/net/wireless/ath/ath10k/wmi.h:1299:	 *   its multicast group membership table.
drivers/net/wireless/ath/ath10k/wmi.h:1300:	 *   These multicast group membership table elements are shared by the
drivers/net/wireless/ath/ath10k/wmi.h:1301:	 *   multicast groups stored within the table.
drivers/net/wireless/ath/ath10k/wmi.h:1306:	 * whether/how to do multicast->unicast conversion
drivers/net/wireless/ath/ath10k/wmi.h:1309:	 *   perform multicast --> unicast conversion on transmit, and if so,
drivers/net/wireless/ath/ath10k/wmi.h:1310:	 *   what to do if it finds no entries in its multicast group
drivers/net/wireless/ath/ath10k/wmi.h:1311:	 *   membership table for the multicast IP address in the tx frame.
drivers/net/wireless/ath/ath10k/wmi.h:1313:	 *   0 -> Do not perform multicast to unicast conversion.
drivers/net/wireless/ath/ath10k/wmi.h:1314:	 *   1 -> Convert multicast frames to unicast, if the IP multicast
drivers/net/wireless/ath/ath10k/wmi.h:1315:	 *        address from the tx frame is found in the multicast group
drivers/net/wireless/ath/ath10k/wmi.h:1316:	 *        membership table.  If the IP multicast address is not found,
drivers/net/wireless/ath/ath10k/wmi.h:1318:	 *   2 -> Convert multicast frames to unicast, if the IP multicast
drivers/net/wireless/ath/ath10k/wmi.h:1319:	 *        address from the tx frame is found in the multicast group
drivers/net/wireless/ath/ath10k/wmi.h:1320:	 *        membership table.  If the IP multicast address is not found,
drivers/net/wireless/ath/ath10k/wmi.h:1321:	 *        transmit the frame as multicast.
drivers/net/wireless/ath/ath10k/wmi.h:1469:	 *   which peers belong to a given multicast group, so that if
drivers/net/wireless/ath/ath10k/wmi.h:1470:	 *   multicast->unicast conversion is enabled, the target can convert
drivers/net/wireless/ath/ath10k/wmi.h:1471:	 *   multicast tx frames to a series of unicast tx frames, to each
drivers/net/wireless/ath/ath10k/wmi.h:1472:	 *   peer within the multicast group.
drivers/net/wireless/ath/ath10k/wmi.h:1474:	 *   many multicast groups to provide storage for within its multicast
drivers/net/wireless/ath/ath10k/wmi.h:1484:	 *   its multicast group membership table.
drivers/net/wireless/ath/ath10k/wmi.h:1485:	 *   These multicast group membership table elements are shared by the
drivers/net/wireless/ath/ath10k/wmi.h:1486:	 *   multicast groups stored within the table.
drivers/net/wireless/ath/ath10k/wmi.h:1491:	 * whether/how to do multicast->unicast conversion
drivers/net/wireless/ath/ath10k/wmi.h:1494:	 *   perform multicast --> unicast conversion on transmit, and if so,
drivers/net/wireless/ath/ath10k/wmi.h:1495:	 *   what to do if it finds no entries in its multicast group
drivers/net/wireless/ath/ath10k/wmi.h:1496:	 *   membership table for the multicast IP address in the tx frame.
drivers/net/wireless/ath/ath10k/wmi.h:1498:	 *   0 -> Do not perform multicast to unicast conversion.
drivers/net/wireless/ath/ath10k/wmi.h:1499:	 *   1 -> Convert multicast frames to unicast, if the IP multicast
drivers/net/wireless/ath/ath10k/wmi.h:1500:	 *        address from the tx frame is found in the multicast group
drivers/net/wireless/ath/ath10k/wmi.h:1501:	 *        membership table.  If the IP multicast address is not found,
drivers/net/wireless/ath/ath10k/wmi.h:1503:	 *   2 -> Convert multicast frames to unicast, if the IP multicast
drivers/net/wireless/ath/ath10k/wmi.h:1504:	 *        address from the tx frame is found in the multicast group
drivers/net/wireless/ath/ath10k/wmi.h:1505:	 *        membership table.  If the IP multicast address is not found,
drivers/net/wireless/ath/ath10k/wmi.h:1506:	 *        transmit the frame as multicast.
drivers/net/wireless/ath/ath10k/wmi.h:3162:	/* Set the custom rate (rate-code) for multicast data frames */
drivers/net/wireless/ath/ath10k/wmi.h:3164:	/* Tx multicast packet indicate Enable/Disable */
drivers/net/wireless/ath/ath10k/wmi.h:3289:	/* Set the custom rate (rate-code) for multicast data frames */
drivers/net/wireless/ath/ath10k/wmi.h:3291:	/* Tx multicast packet indicate Enable/Disable */
drivers/net/wireless/ath/ath10k/mac.c:2442:				    u64 multicast)
drivers/net/wireless/ath/wil6210/cfg80211.c:400:					bool multicast)
drivers/net/wireless/mac80211_hwsim.c:1374:					    unsigned int *total_flags,u64 multicast)
drivers/net/wireless/orinoco/hw.c:679:	/* Reset promiscuity / multicast*/
drivers/net/wireless/orinoco/hw.c:1086:	 * group address if either we want to multicast, or if we were
drivers/net/wireless/orinoco/hw.c:1104:			printk(KERN_ERR "%s: Error %d setting multicast list.\n",
drivers/net/wireless/airo.c:553:#define RXMODE_ADDR cpu_to_le16(2) /* ignore multicast and broadcast */
drivers/net/wireless/airo.c:822:	u8  multicast[16];
drivers/net/wireless/airo.c:1344:		                mic_rid.multicast, sizeof(mic_rid.multicast),
drivers/net/wireless/airo.c:2264:	dev->stats.multicast = le32_to_cpu(vals[43]);
drivers/net/wireless/airo.c:2315:		/* Turn on multicast.  (Should be already setup...) */
drivers/net/wireless/mwifiex/uap_txrx.c:207: * If a packet is multicast/broadcast, it is sent to kernel/upper layer
drivers/net/wireless/mwifiex/sta_cmd.c:399: * This function prepares command to set MAC multicast address.
drivers/net/wireless/mwifiex/sta_cmd.c:403: *      - Setting MAC multicast address
drivers/net/wireless/mwifiex/sta_cmd.c:600:		} else {	/* WAPI group key: multicast */
drivers/net/wireless/mwifiex/sta_cmd.c:652:			else	/* AES group key: multicast */
drivers/net/wireless/mwifiex/sta_cmd.c:667:		else		/* TKIP group key: multicast */
drivers/net/wireless/mwifiex/sta_ioctl.c:33: * Copies the multicast address list from device to driver.
drivers/net/wireless/mwifiex/sta_ioctl.c:78: * issues it to set the multicast list.
drivers/net/wireless/mwifiex/sta_ioctl.c:81: * multicast packets, or to enable selective multicast.
drivers/net/wireless/mwifiex/sta_ioctl.c:108:				"info: Set multicast list=%d\n",
drivers/net/wireless/mwifiex/sta_ioctl.c:110:			/* Send multicast addresses to firmware */
drivers/net/wireless/mwifiex/sta_ioctl.c:945:		 * and sending unicast and multicast packets.
drivers/net/wireless/mwifiex/README:100:	multicase_count = <multicast address count>
drivers/net/wireless/mwifiex/README:105:	multicasr_address[n] = <multicast address>
drivers/net/wireless/mwifiex/main.c:697: * CFG802.11 network device handler for setting multicast list.
drivers/net/wireless/mwifiex/debugfs.c:264: *      - Number of multicast Tx frames
drivers/net/wireless/mwifiex/debugfs.c:267: *      - Number of multicast Tx retries
drivers/net/wireless/mwifiex/debugfs.c:273: *      - Number of multicast Rx frames
drivers/net/wireless/mwifiex/sta_cmdresp.c:499: * This function handles the command response of set/get MAC multicast
drivers/net/wireless/mwifiex/cfg80211.c:385:				 bool multicast)
drivers/net/wireless/iwlwifi/mvm/mac80211.c:856:				     u64 multicast)
drivers/net/wireless/iwlwifi/mvm/mac80211.c:859:	struct iwl_mcast_filter_cmd *cmd = (void *)(unsigned long)multicast;
drivers/net/wireless/iwlwifi/mvm/fw-api.h:1141: * struct iwl_mcast_filter_cmd - configure multicast filter.
drivers/net/wireless/iwlwifi/mvm/fw-api.h:1142: * @filter_own: Set 1 to filter out multicast packets sent by station itself
drivers/net/wireless/iwlwifi/mvm/fw-api.h:1148: * @pass_all:	Set 1 to pass all multicast packets.
drivers/net/wireless/iwlwifi/mvm/fw-api-sta.h:259: * @multicast_tx_key_id: multicast tx key id. Relevant only when multicast key
drivers/net/wireless/iwlwifi/mvm/fw-api-mac.h:153: * @mcast_qid: queue ID for multicast traffic
drivers/net/wireless/iwlwifi/mvm/fw-api-mac.h:259: * @MAC_FILTER_ACCEPT_GRP: accept multicast frames
drivers/net/wireless/iwlwifi/mvm/fw-api-mac.h:261: * @MAC_FILTER_DIS_GRP_DECRYPT: don't decrypt multicast frames
drivers/net/wireless/iwlwifi/dvm/mac80211.c:627:	 * don't expect much multicast traffic in IBSS and having keys
drivers/net/wireless/iwlwifi/dvm/mac80211.c:1047:				    u64 multicast)
drivers/net/wireless/iwlwifi/dvm/mac80211.c:1085:	 * Receiving all multicast frames is always enabled by the
drivers/net/wireless/iwlwifi/dvm/mac80211.c:1087:	 * since we currently do not support programming multicast
drivers/net/wireless/iwlwifi/dvm/commands.h:199: *  - the PAN multicast queue, and
drivers/net/wireless/iwlwifi/dvm/commands.h:1160: * Set this for unicast frames, but not broadcast/multicast. */
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:738:			unsigned int *total_flags, u64 multicast)
drivers/net/wireless/brcm80211/brcmfmac/dhd.h:146: * @multicast_work: worker object for multicast provisioning.
drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c:1854:			       u8 key_idx, bool unicast, bool multicast)
drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c:3253:	/* check for multicast cipher suite */
drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c:3256:		brcmf_err("no multicast cipher suite\n");
drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c:3267:	/* pick up multicast cipher */
drivers/net/wireless/brcm80211/brcmfmac/fwil_types.h:372:	__le32	rx_mcast_pkts;	/* # of multicast packets received */
drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c:318: * @BRCMF_FWS_FIFO_BCMC: fifo for broadcast/multicast (AP only).
drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c:734:	bool multicast;
drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c:736:	multicast = is_multicast_ether_addr(da);
drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c:742:	if (multicast && ifp->fws_desc) {
drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c:1870:	bool multicast = is_multicast_ether_addr(eh->h_dest);
drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c:1878:	drvr->tx_multicast += !!multicast;
drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c:1886:	if (!multicast)
drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c:1896:		  eh->h_dest, multicast, fifo);
drivers/net/wireless/brcm80211/brcmfmac/dhd_linux.c:104:	/* Send down the multicast list first. */
drivers/net/wireless/brcm80211/brcmfmac/dhd_linux.c:293:		ifp->stats.multicast++;
drivers/net/wireless/b43legacy/main.c:2913:					  unsigned int *fflags,u64 multicast)
drivers/net/wireless/rsi/rsi_91x_mac80211.c:790: * @multicast: Multicast.
drivers/net/wireless/rsi/rsi_91x_mac80211.c:797:				     u64 multicast)
drivers/net/wireless/rtlwifi/rtl8192cu/hw.c:827:	/* Accept all multicast address */
drivers/net/wireless/rtlwifi/base.c:617:			if (tcb_desc->multicast || tcb_desc->broadcast) {
drivers/net/wireless/rtlwifi/base.c:680:	if (tcb_desc->multicast || tcb_desc->broadcast)
drivers/net/wireless/rtlwifi/base.c:946:			tcb_desc->multicast = 1;
drivers/net/wireless/rtlwifi/ps.c:505:	/* 2. Maybe the AP wants to send multicast/broadcast data? */
drivers/net/wireless/rtlwifi/ps.c:511:	 * multicast frames here */
drivers/net/wireless/rtlwifi/wifi.h:1615:	u8 multicast:1;
drivers/net/wireless/rtlwifi/pci.c:549:			 * multicast/broadcast/no_qos data */
drivers/net/wireless/rtlwifi/core.c:474:			     unsigned int *new_flags, u64 multicast)
drivers/net/wireless/rtlwifi/core.c:489:				 "Enable receive multicast frame\n");
drivers/net/wireless/rtlwifi/core.c:494:				 "Disable receive multicast frame\n");
drivers/net/wireless/b43/main.c:4163:				    u64 multicast)
drivers/net/wireless/b43/pio.c:48:	 * for multicast frames.
drivers/net/wireless/b43/pio.c:513:		/* The multicast queue will be sent after the DTIM. */
drivers/net/wireless/b43/dma.c:1208:	 * for multicast frames.
drivers/net/wireless/b43/dma.c:1411:		/* The multicast ring will be sent after the DTIM */
drivers/net/wireless/ipw2x00/ipw2200.c:3914:	bssid[0] &= 0xfe;	/* clear multicast bit */
drivers/net/wireless/ipw2x00/ipw2200.c:10288:			 * is a multicast/broadcast packet, because CCMP
drivers/net/wireless/ipw2x00/ipw2100.c:4883: * of the multicast packets as IPv6 needs some. */
drivers/net/wireless/ipw2x00/libipw_rx.c:441:		 * even with broad/multicast targets (this is against IEEE
drivers/net/wireless/ipw2x00/libipw_rx.c:457:			/* This seems to be triggered by some (multicast?)
drivers/net/wireless/ipw2x00/libipw_rx.c:776:			/* copy multicast frame both to the higher layers and
drivers/net/wireless/ipw2x00/libipw_rx.c:782:				       "multicast frame\n", dev->name);
drivers/net/wireless/ipw2x00/libipw.h:757:	/* host performs multicast decryption */
drivers/net/wireless/ipw2x00/libipw.h:777:				 * with RX of broad/multicast frames */
drivers/net/wireless/ipw2x00/libipw_tx.c:381:		/* Determine fragmentation size based on destination (multicast
drivers/net/wireless/libertas_tf/libertas_tf.h:95:*	Current version of MAC has a 32x6 multicast address buffer.
drivers/net/wireless/libertas_tf/main.c:240:	 * there are no buffered multicast frames to send
drivers/net/wireless/libertas_tf/main.c:446:			u64 multicast)
drivers/net/wireless/libertas_tf/main.c:466:	    multicast > MRVDRV_MAX_MULTICAST_LIST_SIZE) {
drivers/net/wireless/libertas_tf/main.c:469:	} else if (multicast) {
drivers/net/wireless/rndis_wlan.c:517:				 u8 key_index, bool unicast, bool multicast);
drivers/net/wireless/rndis_wlan.c:2446:				 u8 key_index, bool unicast, bool multicast)
drivers/net/wireless/rndis_wlan.c:3382:/* same as rndis_netdev_ops but with local multicast handler */
drivers/net/wireless/rndis_wlan.c:3437:	 * so do promisc/multicast handling in rndis_wlan.
drivers/net/wireless/rndis_wlan.c:3545:	/* rndis_reset cleared multicast list, so restore here.
drivers/net/wireless/at76c50x-usb.c:1991:				  unsigned int *total_flags, u64 multicast)
drivers/net/wireless/cw1200/sta.c:547:	/* Disable multicast filtering */
drivers/net/wireless/cw1200/sta.c:556:		pr_debug("[STA] multicast: %pM\n", ha->addr);
drivers/net/wireless/cw1200/sta.c:576:			     u64 multicast)
drivers/net/wireless/cw1200/sta.c:2160:		 arg->multicast ? "broadcast" : "unicast");
drivers/net/wireless/cw1200/sta.c:2162:	if (arg->multicast) {
drivers/net/wireless/cw1200/wsm.h:251:/* Indicates Beacon frame's virtual bitmap contains multicast bit */
drivers/net/wireless/cw1200/wsm.h:1254:	/* Transmit multicast Frames */
drivers/net/wireless/cw1200/wsm.h:1255:	/* [out] */ bool multicast;
drivers/net/wireless/cw1200/txrx.c:882:			.multicast = !link_id,
drivers/net/wireless/cw1200/sta.h:32:			     u64 multicast);
drivers/net/wireless/cw1200/wsm.c:1064:	arg.multicast = !!(flags & 8);
drivers/net/wireless/cw1200/wsm.c:1496:			 * multicast frames in a loop, causing performance
drivers/net/wireless/cw1200/wsm.c:1634:	/* Search for a queue with multicast frames buffered */
drivers/net/wireless/cw1200/wsm.c:1751:				/* more buffered multicast/broadcast frames
drivers/net/wireless/bcmdhd/include/proto/802.11.h:2967:	struct ether_addr mcast_ea;  /* The multicast MAC address */
drivers/net/wireless/bcmdhd/include/proto/wpa.h:47:#define DOT11_RC_INVALID_MC_CIPHER	18	/* Invalid multicast cipher */
drivers/net/wireless/bcmdhd/include/proto/wpa.h:84:/* WPA suite/multicast suite */
drivers/net/wireless/bcmdhd/include/proto/bcmevent.h:149:#define WLC_E_MULTICAST_DECODE_ERROR	51	/* Unsupported multicast encrypted frame */
drivers/net/wireless/bcmdhd/include/proto/ethernet.h:153: * Takes a pointer, returns true if a 48-bit multicast address
drivers/net/wireless/bcmdhd/include/devctrl_if/wlioctl_defs.h:1237:/* any multicast cipher suite */
drivers/net/wireless/bcmdhd/include/wlioctl.h:899:	uint32			rx_mcast_pkts;	/* # of multicast packets received */
drivers/net/wireless/bcmdhd/include/wlioctl.h:1523: *   uint8 mcipher[DOT11_OUI_LEN+1]; multicast cipher suite
drivers/net/wireless/bcmdhd/include/wlioctl.h:1526: * multicast cipher suite can be specified as a specific cipher suite or WL_WPA_ACP_MCS_ANY.
drivers/net/wireless/bcmdhd/include/wlioctl.h:1645:	uint32	rxdfrmmcast;	/* number of RX Data multicast frames received by the MAC */
drivers/net/wireless/bcmdhd/include/wlioctl.h:1646:	uint32	rxmfrmmcast;	/* number of RX Management multicast frames received by the MAC */
drivers/net/wireless/bcmdhd/include/wlioctl.h:1647:	uint32	rxcfrmmcast;	/* number of RX Control multicast frames received by the MAC
drivers/net/wireless/bcmdhd/include/wlioctl.h:1750:	uint32	pktengrxdmcast; /* multicast frames rxed by the pkteng code */
drivers/net/wireless/bcmdhd/include/wlioctl.h:1899:	uint32  rxdfrmmcast;    /* number of RX Data multicast frames received by the MAC */
drivers/net/wireless/bcmdhd/include/wlioctl.h:1900:	uint32  rxmfrmmcast;    /* number of RX Management multicast frames received by the MAC */
drivers/net/wireless/bcmdhd/include/wlioctl.h:1901:	uint32  rxcfrmmcast;    /* number of RX Control multicast frames received by the MAC
drivers/net/wireless/bcmdhd/include/wlioctl.h:2021:	uint32  pktengrxdmcast; /* multicast frames rxed by the pkteng code */
drivers/net/wireless/bcmdhd/wl_android.c:1337:			/* Set to 0 to match any available multicast cipher */
drivers/net/wireless/bcmdhd/dhd_cdc.c:503:	dhd->dstats.multicast = dhd->rx_multicast;
drivers/net/wireless/bcmdhd/dhd_common.c:231:	bcm_bprintf(strbuf, "multicast %lu\n", dhdp->dstats.multicast);
drivers/net/wireless/bcmdhd/dngl_stats.h:40:	unsigned long   multicast;      /* multicast packets received */
drivers/net/wireless/bcmdhd/wl_cfg80211.c:347:	u8 key_idx, bool unicast, bool multicast);
drivers/net/wireless/bcmdhd/wl_cfg80211.c:3911:	u8 key_idx, bool unicast, bool multicast)
drivers/net/wireless/bcmdhd/wl_cfg80211.c:5953:	/* check for multicast cipher suite */
drivers/net/wireless/bcmdhd/wl_cfg80211.c:5955:		WL_INFO(("no multicast cipher suite\n"));
drivers/net/wireless/bcmdhd/wl_cfg80211.c:5959:	/* pick up multicast cipher */
drivers/net/wireless/bcmdhd/dhd_linux.c:374:	/* Thread to issue ioctl for multicast */
drivers/net/wireless/bcmdhd/dhd_linux.c:1219:	/* Send down the multicast list first. */
drivers/net/wireless/bcmdhd/dhd_linux.c:1548:	DHD_INFO(("%s: set multicast list for if %d\n", __FUNCTION__, ifidx));
drivers/net/wireless/bcmdhd/dhd_linux.c:1634:	/* Update multicast statistic */
drivers/net/wireless/bcmdhd/dhd_linux.c:2028:			ifp->stats.multicast++;
drivers/net/arcnet/com20020.c:317:/* Set or clear the multicast filter for this adaptor.
drivers/net/arcnet/com20020.c:319: * num_addrs == 0       Normal mode, clear multicast list
drivers/net/arcnet/com20020.c:322: *      FIXME - do multicast stuff, not just promiscuous.
Binary file drivers/net/usb/smsc75xx.o matches
drivers/net/usb/asix_devices.c:156:		/* Build the multicast hash filter. */
drivers/net/usb/qmi_wwan.c:68: * header will have either our address or a broadcast/multicast
drivers/net/usb/mcs7830.c:386:		/* Build the multicast hash filter. */
drivers/net/usb/lg-vl600.c:92:	/* IPv6 NDP relies on multicast.  Enable it by default. */
drivers/net/usb/int51x1.c:130:		netdev_dbg(dev->net, "receive all multicast enabled\n");
drivers/net/usb/catc.c:181:	u8 multicast[64];
drivers/net/usb/catc.c:629:static void catc_multicast(unsigned char *addr, u8 *multicast)
drivers/net/usb/catc.c:634:	multicast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);
drivers/net/usb/catc.c:645:	memset(catc->multicast, 0, 64);
drivers/net/usb/catc.c:647:	catc_multicast(broadcast, catc->multicast);
drivers/net/usb/catc.c:648:	catc_multicast(netdev->dev_addr, catc->multicast);
drivers/net/usb/catc.c:651:		memset(catc->multicast, 0xff, 64);
drivers/net/usb/catc.c:656:		memset(catc->multicast, 0xff, 64);
drivers/net/usb/catc.c:661:				catc->multicast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);
drivers/net/usb/catc.c:663:				catc->multicast[7-(crc >> 29)] |= 1 << ((crc >> 26) & 7);
drivers/net/usb/catc.c:669:		catc_write_mem_async(catc, 0xfa80, catc->multicast, 64);
drivers/net/usb/catc.c:671:		f5u011_mchash_async(catc, catc->multicast);
drivers/net/usb/catc.c:881:		dev_dbg(dev, "Filling the multicast list.\n");
drivers/net/usb/catc.c:884:		catc_multicast(broadcast, catc->multicast);
drivers/net/usb/catc.c:885:		catc_multicast(netdev->dev_addr, catc->multicast);
drivers/net/usb/catc.c:886:		catc_write_mem(catc, 0xfa80, catc->multicast, 64);
drivers/net/usb/asix_common.c:347:		/* Build the multicast hash filter. */
drivers/net/usb/smsc95xx.c:474:		netif_dbg(dev, drv, dev->net, "receive all multicast enabled\n");
drivers/net/usb/smsc95xx.c:1525:			netdev_info(dev->net, "enabling multicast detection\n");
drivers/net/usb/r8152.c:537:/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
drivers/net/usb/sr9800.c:319:		/* Build the multicast hash filter. */
drivers/net/usb/cdc_ether.c:455:	/* FIXME cdc-ether has some multicast code too, though it complains
drivers/net/usb/cdc_ether.c:456:	 * in routine cases.  info->ether describes the multicast support.
drivers/net/usb/kaweth.c:38: * Smart multicast support
Binary file drivers/net/usb/smsc95xx.o matches
drivers/net/usb/smsc75xx.c:536:	netif_dbg(dev, drv, dev->net, "deferred multicast write 0x%08x\n",
drivers/net/usb/smsc75xx.c:567:		netif_dbg(dev, drv, dev->net, "receive all multicast enabled\n");
drivers/net/usb/smsc75xx.c:572:		netif_dbg(dev, drv, dev->net, "receive multicast hash filter\n");
drivers/net/usb/smsc75xx.c:1835:			netdev_info(dev->net, "enabling multicast detection\n");
drivers/net/hamradio/bpqether.c:321: *					or multicast: accept all)
drivers/net/ppp/ppp_generic.c:67:#define NP_MPLS_MC 5		/* MPLS multicast */
drivers/net/wan/hdlc_cisco.c:26:#define CISCO_MULTICAST		0x8F	/* Cisco multicast address */
drivers/net/wan/sdla.c:675:	 * stupid GateD insists on setting up the multicast router thru us
drivers/net/vxlan.c:537:/* Add/update destinations for multicast */
drivers/net/vxlan.c:745:		/* Disallow replace to add a multicast entry */
drivers/net/vxlan.c:1018:/* See if multicast group is already in use by other ID */
drivers/net/vxlan.c:1074:/* Callback to update multicast group membership when first VNI on
drivers/net/vxlan.c:1075: * multicast asddress is brought up
drivers/net/vxlan.c:1210:	/* Ignore packet loops (and multicast echo) */
drivers/net/vxlan.c:2453:	/* Disable multicast loopback */
drivers/net/vxlan.c:2497:	/* Disable multicast loopback */
drivers/net/bonding/bond_alb.c:1402:		/* IPv6 uses all-nodes multicast as an equivalent to
drivers/net/bonding/bond_main.c:545: * Retrieve the list of registered multicast addresses for the bonding
drivers/net/bonding/bond_main.c:1258:			/* Flush unicast and multicast addresses */
drivers/net/bonding/bond_main.c:3142:		stats->multicast += sstats->multicast;
drivers/net/cris/eth_v10.c:1550: * Set or clear the multicast filter for this adaptor.
drivers/net/cris/eth_v10.c:1552: * num_addrs == 0	Normal mode, clear multicast list
drivers/net/ethernet/s6gmac.c:444:	S6_STATS_C(S6_GMAC_STATCARRY1_RMCA, S6_GMAC_STATRMCA, multicast)
drivers/net/ethernet/aeroflex/greth.c:1065:	if (greth->multicast) {
drivers/net/ethernet/aeroflex/greth.c:1080:		/* Setup multicast filter */
drivers/net/ethernet/aeroflex/greth.c:1445:	/* Check for multicast capability */
drivers/net/ethernet/aeroflex/greth.c:1446:	greth->multicast = (tmp >> 25) & 1;
drivers/net/ethernet/aeroflex/greth.c:1530:	if (greth->multicast) {
drivers/net/ethernet/aeroflex/greth.h:136:	u8 multicast;
drivers/net/ethernet/octeon/octeon_mgmt.c:587:	unsigned int multicast_mode = 1; /* 1 - Reject all multicast.  */
drivers/net/ethernet/octeon/octeon_mgmt.c:607:			multicast_mode = 2; /* 2 - Accept all multicast.  */
drivers/net/ethernet/sun/sunqe.c:245:	/* Reload multicast information, this will enable the receiver
drivers/net/ethernet/sun/sungem.h:569: * Address, which must be the reserved multicast address for MAC
drivers/net/ethernet/sun/cassini.h:1441:						   multicast frames (group
drivers/net/ethernet/sun/cassini.h:1444:						   multicast addresses */
drivers/net/ethernet/sun/cassini.h:1448:						   and multicast
drivers/net/ethernet/sun/cassini.h:1572: *    MAC CTRL addr must be the reserved multicast addr for MAC CTRL frames.
drivers/net/ethernet/sun/cassini.c:2956:			 * first 15 multicast addresses
drivers/net/ethernet/sun/cassini.c:2968:			 * multicast addresses
drivers/net/ethernet/sun/niu.h:3252:#define NIU_FLAGS_MCAST			0x00200000 /* multicast filter enabled */
drivers/net/ethernet/jme.c:1069:			++(NET_STAT(jme).multicast);
drivers/net/ethernet/cirrus/cs89x0.c:1202:		/* The multicast-accept list is initialized to accept-all,
drivers/net/ethernet/cirrus/mac89x0.c:576:		/* The multicast-accept list is initialized to accept-all, and we
drivers/net/ethernet/moxa/moxart_ether.c:245:			priv->stats.multicast++;
drivers/net/ethernet/moxa/moxart_ether.h:172:#define RX_MULTIPKT		BIT(16)	/* receive all multicast packets */
drivers/net/ethernet/adaptec/starfire.c:83:/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).
drivers/net/ethernet/adaptec/starfire.c:1776:		/* Must use a multicast hash table. */
drivers/net/ethernet/fealnx.c:34:/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast). */
drivers/net/ethernet/fealnx.c:122:MODULE_PARM_DESC(multicast_filter_limit, "fealnx maximum number of filtered multicast addresses");
drivers/net/ethernet/fealnx.c:163:	MAR0 = 0x08,		/* multicast address 0-3 */
drivers/net/ethernet/fealnx.c:164:	MAR1 = 0x0C,		/* multicast address 4-7 */
drivers/net/ethernet/fealnx.c:254:	MARSTATUS = 0x00004000,	/* multicast address received */
drivers/net/ethernet/marvell/mvneta.c:1748:/* This method controls the net device special MAC multicast support.
drivers/net/ethernet/marvell/mvneta.c:1782:/* This method controls the network device Other MAC multicast support.
drivers/net/ethernet/marvell/mvneta.c:1783: * The Other Multicast Table is used for multicast of another type.
drivers/net/ethernet/marvell/mvneta.c:1814:/* The network device supports multicast using two tables:
drivers/net/ethernet/marvell/mvneta.c:1819: *    2) Other Multicast Table for multicast of another type. A CRC-8 value
drivers/net/ethernet/marvell/mvneta.c:1883:/* register unicast and multicast addresses */
drivers/net/ethernet/marvell/mvneta.c:1902:			/* Accept all multicast */
drivers/net/ethernet/marvell/mvneta.c:1906:			/* Accept only initialized multicast */
drivers/net/ethernet/marvell/pxa168_eth.c:594:	 * and multicast address.
drivers/net/ethernet/marvell/skge.c:473:	dev->stats.multicast = data[3] + data[5];
drivers/net/ethernet/marvell/skge.c:2148:	/* receive control reg: unicast + multicast + no FCS  */
drivers/net/ethernet/marvell/skge.c:2990:	else if (dev->flags & IFF_ALLMULTI)	/* all multicast */
drivers/net/ethernet/marvell/skge.c:2992:	else if (netdev_mc_empty(dev) && !rx_pause)/* no multicast */
drivers/net/ethernet/marvell/sky2.c:954:	/* receive control reg: unicast + multicast + no FCS  */
drivers/net/ethernet/marvell/sky2.c:3926:	stats->multicast = get_stats32(hw, port, GM_RXF_MC_OK)
drivers/net/ethernet/ethoc.c:830:	/* receive multicast frames */
drivers/net/ethernet/rdc/r6040.c:67:#define  MCR0_HASH_EN	0x0100	/* Enable multicast hash table function */
drivers/net/ethernet/rdc/r6040.c:144:#define MCAST_MAX	3	/* Max number multicast addresses to filter */
drivers/net/ethernet/rdc/r6040.c:158:#define DSC_RX_MCAST	0x0010	/* RX multicast (no error) */
drivers/net/ethernet/rdc/r6040.c:159:#define DSC_RX_MCH_HIT	0x0008	/* RX multicast hit in hash table (no error) */
drivers/net/ethernet/rdc/r6040.c:457:	dev->stats.multicast += ioread8(ioaddr + ME_CNT0);
drivers/net/ethernet/rdc/r6040.c:888:	/* Enable multicast hash table function to
drivers/net/ethernet/rdc/r6040.c:889:	 * receive all multicast packets. */
drivers/net/ethernet/rdc/r6040.c:902:	/* Use internal multicast address registers if the number of
drivers/net/ethernet/rdc/r6040.c:903:	 * multicast addresses is not greater than MCAST_MAX. */
drivers/net/ethernet/rdc/r6040.c:920:	/* Otherwise, Enable multicast hash table function. */
drivers/net/ethernet/rdc/r6040.c:932:		/* Build multicast hash table */
drivers/net/ethernet/hp/hp100.h:75:#define HP100_REG_HASH_BYTE0	0x10	/* RW: (8) Cards multicast filter    */
drivers/net/ethernet/hp/hp100.h:409:#define HP100_ACC_MC		0x04	/* 0:No, 1:Yes allow Rx of multicast pkts */
drivers/net/ethernet/hp/hp100.h:575:#define HP100_MULTI_ADDR_HASH	0x0006	/* 110: Addr multicast, matched hash */
drivers/net/ethernet/hp/hp100.h:577:#define HP100_MULTI_ADDR_NO_HASH 0x0002	/* 010: Addr multicast, didn't match hash */
drivers/net/ethernet/hp/hp100.c:75:**   - added hardware multicast filter support (doesn't work)
drivers/net/ethernet/hp/hp100.c:82:**   - fixed bug in multicast support
drivers/net/ethernet/hp/hp100.c:883:	 * multicast filter...
drivers/net/ethernet/hp/hp100.c:1041:	/* Zero the multicast hash registers */
drivers/net/ethernet/hp/hp100.c:1049:	/* Zero accept error, accept multicast, accept broadcast and accept */
drivers/net/ethernet/hp/hp100.c:1861:			dev->stats.multicast++;
drivers/net/ethernet/hp/hp100.c:1948:				dev->stats.multicast++;
drivers/net/ethernet/hp/hp100.c:2059: *  multicast setup
drivers/net/ethernet/hp/hp100.c:2063: *  Set or clear the multicast filter for this adapter.
drivers/net/ethernet/hp/hp100.c:2087:		lp->mac2_mode = HP100_MAC2MODE5;	/* multicast mode = get packets for */
drivers/net/ethernet/hp/hp100.c:2091:			/* set hash filter to receive all multicast packets */
drivers/net/ethernet/hp/hp100.c:2106:				printk("hp100: %s: multicast = %pM, ",
drivers/net/ethernet/hp/hp100.c:2140:		printk("hp100: %s: mac1 = 0x%x, mac2 = 0x%x, multicast hash = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
drivers/net/ethernet/hp/hp100.c:2165:			printk("hp100: %s: multicast hash = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
drivers/net/ethernet/via/via-velocity.h:89:#define RSR_MAR		cpu_to_le16(0x2000) // MAC accept multicast address packet
drivers/net/ethernet/via/via-velocity.h:902:#define WOLCFG_SAM              0x20	/* accept multicast case reset, default=0 */
drivers/net/ethernet/via/via-velocity.c:2065:		stats->multicast++;
drivers/net/ethernet/via/via-rhine.c:65:/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).
drivers/net/ethernet/via/via-rhine.c:1289: * rhine_set_cam - set CAM multicast filters
drivers/net/ethernet/via/via-rhine.c:1291: * @idx: multicast CAM index [0..MCAM_SIZE-1]
drivers/net/ethernet/via/via-rhine.c:1292: * @addr: multicast address (6 bytes)
drivers/net/ethernet/via/via-rhine.c:1294: * Load addresses into multicast filters.
drivers/net/ethernet/via/via-rhine.c:1348: * rhine_set_cam_mask - set multicast CAM mask
drivers/net/ethernet/via/via-rhine.c:1350: * @mask: multicast CAM mask
drivers/net/ethernet/via/via-rhine.c:1352: * Mask sets multicast filters active/inactive.
drivers/net/ethernet/via/via-rhine.c:1389: * Initialize (disable) hardware VLAN and multicast support on this
drivers/net/ethernet/atheros/atlx/atl1.h:326:	u32 rx_mcast;		/* good RX multicast packets */
drivers/net/ethernet/atheros/atlx/atl1.h:346:	u32 rx_mcast_byte_cnt;	/* RX multicast bytes, excluding FCS */
drivers/net/ethernet/atheros/atlx/atl1.h:352:	u32 tx_mcast;		/* good TX multicast packets */
drivers/net/ethernet/atheros/atlx/atl1.h:376:	u32 tx_mcast_byte;	/* multicast bytes transmitted, excluding FCS */
drivers/net/ethernet/atheros/atlx/atl1.h:664:	u64 multicast;
drivers/net/ethernet/atheros/atlx/atl2.c:130: * The set_multi entry point is called whenever the multicast address
drivers/net/ethernet/atheros/atlx/atl2.c:132: * responsible for configuring the hardware for proper multicast,
drivers/net/ethernet/atheros/atlx/atl2.c:156:	/* clear the old settings from the multicast hash table */
drivers/net/ethernet/atheros/atlx/atl2.c:466:				netdev->stats.multicast++;
drivers/net/ethernet/atheros/atlx/atl2.c:1578:			/* magic packet maybe Broadcast&multicast&Unicast */
drivers/net/ethernet/atheros/atlx/atl2.c:2353: * Hashes an address to determine its location in the multicast table
drivers/net/ethernet/atheros/atlx/atl2.c:2356: * mc_addr - the multicast address to hash
drivers/net/ethernet/atheros/atlx/atl2.c:2360: *      set hash value for a multicast address
drivers/net/ethernet/atheros/atlx/atl2.c:2362: *          1. calcu 32bit CRC for multicast address
drivers/net/ethernet/atheros/atlx/atl2.c:2380: * Sets the bit in the multicast table corresponding to the hash value.
drivers/net/ethernet/atheros/atlx/atl2.c:2450:* post-reset uninitialized state. Initializes multicast table,
drivers/net/ethernet/atheros/atlx/atl2.c:2461:	/* clear the old settings from the multicast hash table */
drivers/net/ethernet/atheros/atlx/atlx.c:121: * The set_multi entry point is called whenever the multicast address
drivers/net/ethernet/atheros/atlx/atlx.c:123: * responsible for configuring the hardware for proper multicast,
drivers/net/ethernet/atheros/atlx/atlx.c:146:	/* clear the old settings from the multicast hash table */
drivers/net/ethernet/atheros/atlx/atlx.h:238:/* Hash table for multicast address */
drivers/net/ethernet/atheros/atlx/atl2.h:257:	unsigned mcast:1;	/* multicast packet */
drivers/net/ethernet/atheros/atlx/atl2.h:306:	unsigned mcast:1;	/* current packet is multicast */
drivers/net/ethernet/atheros/atlx/atl1.c:41: * multicast
drivers/net/ethernet/atheros/atlx/atl1.c:551: * Hashes an address to determine its location in the multicast table
drivers/net/ethernet/atheros/atlx/atl1.c:553: * mc_addr - the multicast address to hash
drivers/net/ethernet/atheros/atlx/atl1.c:557: *      set hash value for a multicast address
drivers/net/ethernet/atheros/atlx/atl1.c:559: *          1. calcu 32bit CRC for multicast address
drivers/net/ethernet/atheros/atlx/atl1.c:575: * Sets the bit in the multicast table corresponding to the hash value.
drivers/net/ethernet/atheros/atlx/atl1.c:848: * post-reset uninitialized state. Initializes multicast table,
drivers/net/ethernet/atheros/atlx/atl1.c:858:	/* clear the old settings from the multicast hash table */
drivers/net/ethernet/atheros/atlx/atl1.c:1698:	adapter->soft_stats.multicast += smb->rx_mcast;
drivers/net/ethernet/atheros/atlx/atl1.c:1732:	netdev->stats.multicast = adapter->soft_stats.multicast;
drivers/net/ethernet/atheros/atlx/atl1.c:3172:	{"multicast", ATL1_STAT(soft_stats.multicast)},
drivers/net/ethernet/atheros/alx/main.c:1183:	net_stats->multicast  = hw_stats->rx_mcast;
drivers/net/ethernet/atheros/alx/hw.h:394:	u64 rx_mcast;		/* good RX multicast packets */
drivers/net/ethernet/atheros/alx/hw.h:414:	u64 rx_mc_byte_cnt;	/* RX multicast bytes, excluding FCS */
drivers/net/ethernet/atheros/alx/hw.h:420:	u64 tx_mcast;		/* good TX multicast packets */
drivers/net/ethernet/atheros/alx/hw.h:446:	u64 tx_mc_byte_cnt;	/* multicast bytes transmitted, excluding FCS */
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:382: * The set_multi entry point is called whenever the multicast address
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:384: * responsible for configuring the hardware for proper multicast,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:409:	/* clear the old settings from the multicast hash table */
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:1505:	net_stats->multicast  = hw_stats->rx_mcast;
drivers/net/ethernet/atheros/atl1c/atl1c_hw.h:426:/* Hash table for multicast address */
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:211: *      set hash value for a multicast address
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:213: *          1. calcu 32bit CRC for multicast address
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:230: * Sets the bit in the multicast table corresponding to the hash value.
drivers/net/ethernet/atheros/atl1c/atl1c.h:316:	unsigned long rx_mcast;		/* The number of good multicast packet received. */
drivers/net/ethernet/atheros/atl1c/atl1c.h:336:	unsigned long rx_mcast_byte_cnt; /* The byte count of multicast packet received, excluding FCS. */
drivers/net/ethernet/atheros/atl1c/atl1c.h:342:	unsigned long tx_mcast;		/* The number of good multicast packet transmitted. */
drivers/net/ethernet/atheros/atl1c/atl1c.h:364:	unsigned long tx_mcast_byte;	/* The byte count of multicast packet transmitted, excluding FCS. */
drivers/net/ethernet/atheros/atl1e/atl1e.h:263:	unsigned long rx_mcast;       /* The number of good multicast packet received. */
drivers/net/ethernet/atheros/atl1e/atl1e.h:283:	unsigned long rx_mcast_byte_cnt;  /* The byte count of multicast packet received, excluding FCS. */
drivers/net/ethernet/atheros/atl1e/atl1e.h:289:	unsigned long tx_mcast;       /* The number of good multicast packet transmitted. */
drivers/net/ethernet/atheros/atl1e/atl1e.h:311:	unsigned long tx_mcast_byte;  /* The byte count of multicast packet transmitted, excluding FCS. */
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:278: * The set_multi entry point is called whenever the multicast address
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:280: * responsible for configuring the hardware for proper multicast,
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:305:	/* clear the old settings from the multicast hash table */
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:1182:	net_stats->multicast  = hw_stats->rx_mcast;
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:2168:		/* magic packet maybe Broadcast&multicast&Unicast frame */
drivers/net/ethernet/atheros/atl1e/atl1e_hw.c:165: *      set hash value for a multicast address
drivers/net/ethernet/atheros/atl1e/atl1e_hw.c:181: * Sets the bit in the multicast table corresponding to the hash value.
drivers/net/ethernet/atheros/atl1e/atl1e_hw.c:569: * post-reset uninitialized state. Initializes multicast table,
drivers/net/ethernet/atheros/atl1e/atl1e_hw.c:580:	/* clear the old settings from the multicast hash table */
drivers/net/ethernet/atheros/atl1e/atl1e_hw.h:302:#define     MAC_CTRL_MC_ALL_EN          0x2000000 /* 1: upload all multicast frame without error to system */
drivers/net/ethernet/atheros/atl1e/atl1e_hw.h:320:/* Hash table for multicast address */
drivers/net/ethernet/microchip/enc28j60.c:1398: * Set or clear the multicast filter for this adapter
drivers/net/ethernet/microchip/enc28j60.c:1400: * num_addrs == 0	Normal mode, filter out multicast packets
drivers/net/ethernet/microchip/enc28j60.c:1438:			printk(KERN_DEBUG DRV_NAME ": multicast mode\n");
drivers/net/ethernet/sis/sis900.c:202:MODULE_PARM_DESC(multicast_filter_limit, "SiS 900/7016 maximum number of filtered multicast addresses");
drivers/net/ethernet/sis/sis900.c:1819:				net_dev->stats.multicast++;
drivers/net/ethernet/sis/sis900.c:2073: *	multicast, unicast or arp).
drivers/net/ethernet/sis/sis900.c:2272: *	@addr: multicast address
drivers/net/ethernet/sis/sis900.c:2275: *	SiS 900 uses the most sigificant 7 bits to index a 128 bits multicast
drivers/net/ethernet/sis/sis900.c:2278: *   	multicast hash table.
drivers/net/ethernet/sis/sis900.c:2297: *	Set SiS900 receive mode for promiscuous, multicast, or broadcast mode.
drivers/net/ethernet/sis/sis900.c:2298: *	And set the appropriate multicast filter.
drivers/net/ethernet/sis/sis900.c:2306:	u16 mc_filter[16] = {0};	/* 256/128 bits multicast hash table */
drivers/net/ethernet/sis/sis900.c:2324:		/* too many multicast addresses or accept all multicast packet */
drivers/net/ethernet/sis/sis190.c:360: * Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
drivers/net/ethernet/sis/sis190.c:633:				stats->multicast++;
drivers/net/ethernet/tundra/tsi108_eth.c:405:			      &data->stats.multicast);
drivers/net/ethernet/tundra/tsi108_eth.c:515:	data->tmpstats.multicast =
drivers/net/ethernet/tundra/tsi108_eth.c:518:			     TSI108_STAT_RXMCAST_CARRY, &data->stats.multicast);
drivers/net/ethernet/arc/emac_main.c:670:	/* FIXME :: no multicast support yet */
drivers/net/ethernet/alteon/acenic.c:265: * - Proper multicast support.
drivers/net/ethernet/alteon/acenic.c:2780:	 * For the time being multicast relies on the upper layers
drivers/net/ethernet/alteon/acenic.c:2782:	 * set the entire multicast list at a time and keeping track of
drivers/net/ethernet/alteon/acenic.c:2806:	dev->stats.multicast = readl(&mac_stats->kept_mc);
drivers/net/ethernet/realtek/atp.c:99:	bank contains only the multicast filter table (now used) and the EEPROM
drivers/net/ethernet/realtek/atp.c:848: *	Set or clear the multicast filter for this adapter.
drivers/net/ethernet/realtek/r8169.c:77:/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
drivers/net/ethernet/realtek/r8169.c:1934:	"multicast",
drivers/net/ethernet/realtek/8139too.c:156:/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
drivers/net/ethernet/realtek/8139too.c:443:	Cfg5_MWF        = (1 << 5), /* 1 = accept multicast wakeup frame */
drivers/net/ethernet/realtek/8139too.c:630:MODULE_PARM_DESC (multicast_filter_limit, "8139too maximum number of filtered multicast addresses");
drivers/net/ethernet/realtek/8139too.c:1898:	/* A.C.: Reset the multicast list. */
drivers/net/ethernet/realtek/8139too.c:2539:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/realtek/8139cp.c:94:/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
drivers/net/ethernet/realtek/8139cp.c:98:MODULE_PARM_DESC (multicast_filter_limit, "8139cp: maximum number of filtered multicast addresses");
drivers/net/ethernet/realtek/8139cp.c:201:	RxMcast		= (1 << 26), /* Rx multicast packet rcv'd */
drivers/net/ethernet/realtek/8139cp.c:216:	AcceptMulticast	= 0x04,	     /* Accept multicast packets */
drivers/net/ethernet/realtek/8139cp.c:907:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/calxeda/xgmac.c:143:#define XGMAC_FRAME_FILTER_PM	0x00000010	/* Pass all multicast */
drivers/net/ethernet/calxeda/xgmac.c:1271: *  xgmac_set_rx_mode - entry point for multicast addressing
drivers/net/ethernet/calxeda/xgmac.c:1275: *  whenever multicast addresses must be enabled/disabled.
drivers/net/ethernet/calxeda/xgmac.c:1478:	storage->multicast = readl(base + XGMAC_MMC_RXMCFRAME_G);
drivers/net/ethernet/chelsio/cxgb/pm3393.c:371:		/* Accept all multicast. */
drivers/net/ethernet/chelsio/cxgb/pm3393.c:378:		/* Accept one or more multicast(s). */
drivers/net/ethernet/chelsio/cxgb/vsc7326_reg.h:207:	RxMulticast		= 0x07,	// # good multicast frames
drivers/net/ethernet/chelsio/cxgb/vsc7326_reg.h:229:	TxMulticast		= 0x1c,	// # frames multicast
drivers/net/ethernet/chelsio/cxgb/cxgb2.c:322:	ns->multicast  = pstats->RxMulticastFramesOK;
drivers/net/ethernet/chelsio/cxgb3/common.h:196:	u64 tx_mcast_frames;	/* good multicast frames */
drivers/net/ethernet/chelsio/cxgb3/common.h:220:	u64 rx_mcast_frames;	/* good multicast frames */
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:1500:	ns->multicast = pstats->rx_mcast_frames;
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c:1170:	/* stop broadcast, multicast, promiscuous mode traffic */
drivers/net/ethernet/chelsio/cxgb3/xgmac.c:37: * the rest are available for multicast addresses.
drivers/net/ethernet/chelsio/cxgb3/xgmac.c:253: * unicast addresses.  Caller should reload the unicast and multicast addresses
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:473: * Configure the exact and hash address filters to handle a port's multicast
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:504:	/* next set up the multicast addresses */
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:4307:	ns->multicast  = stats.rx_mcast_frames;
drivers/net/ethernet/chelsio/cxgb4/cxgb4.h:112:	u64 tx_mcast_frames;      /* all multicast frames */
drivers/net/ethernet/chelsio/cxgb4/cxgb4.h:138:	u64 rx_mcast_frames;      /* all multicast frames */
drivers/net/ethernet/chelsio/cxgb4vf/t4vf_common.h:81:	u64 tx_mcast_bytes;		/* multicast */
drivers/net/ethernet/chelsio/cxgb4vf/t4vf_common.h:94:	u64 rx_mcast_bytes;		/* multicast */
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:818:	ns->multicast = stats.rx_mcast_frames;
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:849: * Collect up to maxaddrs worth of a netdevice's multicast addresses, starting
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:872: * Configure the exact and hash address filters to handle a port's multicast
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:900:	/* next set up the multicast addresses */
drivers/net/ethernet/fujitsu/fmvj18x_cs.c:136:#define MAR_ADR                 8 /* multicast address registers (bank 1) */
drivers/net/ethernet/fujitsu/fmvj18x_cs.c:904:    /* (re)initialize the multicast table */
drivers/net/ethernet/fujitsu/fmvj18x_cs.c:1118:  Set the multicast/promiscuous mode for this adaptor.
drivers/net/ethernet/fujitsu/fmvj18x_cs.c:1161:    /* Switch to bank 1 and set the multicast table. */
drivers/net/ethernet/ti/tlan.c:1227: *			multicast list for.
drivers/net/ethernet/ti/tlan.c:1234: *	Otherwise, the first three multicast addresses are
drivers/net/ethernet/ti/davinci_emac.c:787:	/* if counter still > 0, at least one multicast address refers
drivers/net/ethernet/ti/davinci_emac.c:804:/* EMAC multicast operation */
drivers/net/ethernet/ti/davinci_emac.c:811: * emac_add_mcast - Set multicast address in the EMAC adapter (Internal)
drivers/net/ethernet/ti/davinci_emac.c:813: * @action: multicast operation to perform
drivers/net/ethernet/ti/davinci_emac.c:816: * Set multicast addresses in EMAC adapter - internal function
drivers/net/ethernet/ti/davinci_emac.c:859: * emac_dev_mcast_set - Set multicast address in the EMAC adapter
drivers/net/ethernet/ti/davinci_emac.c:862: * Set multicast addresses in EMAC adapter
drivers/net/ethernet/ti/davinci_emac.c:885:			/* program multicast address list into EMAC hardware */
drivers/net/ethernet/ti/davinci_emac.c:1738:	ndev->stats.multicast += emac_read(EMAC_RXMCASTFRAMES);
drivers/net/ethernet/ti/cpsw_ale.c:250:		/* if vid passed is -1 then remove all multicast entry from
drivers/net/ethernet/ti/cpsw_ale.c:252:		 * passed then remove only multicast added to that vlan id.
drivers/net/ethernet/ti/cpmac.c:343:			/* enable all multicast mode */
drivers/net/ethernet/ti/cpsw.c:646:		/* program multicast address list into ALE register */
drivers/net/ethernet/xilinx/ll_temac_main.c:24: * - Fix multicast assignment.
drivers/net/ethernet/xilinx/ll_temac_main.c:1018:	ndev->flags &= ~IFF_MULTICAST;  /* clear multicast */
drivers/net/ethernet/xilinx/xilinx_axienet_main.c:17: *  - Test and fix basic multicast filtering.
drivers/net/ethernet/xilinx/xilinx_axienet_main.c:18: *  - Add support for extended multicast filtering.
drivers/net/ethernet/xilinx/xilinx_axienet_main.c:337: * axienet_set_multicast_list - Prepare the multicast table
drivers/net/ethernet/xilinx/xilinx_axienet_main.c:340: * This function is called to initialize the multicast table during
drivers/net/ethernet/xilinx/xilinx_axienet_main.c:341: * initialization. The Axi Ethernet basic multicast support has a four-entry
drivers/net/ethernet/xilinx/xilinx_axienet_main.c:342: * multicast table which is initialized here. Additionally this function
drivers/net/ethernet/xilinx/xilinx_axienet_main.c:344: * means whenever the multicast table entries need to be updated this
drivers/net/ethernet/xilinx/xilinx_axienet_main.c:1492:	ndev->flags &= ~IFF_MULTICAST;  /* clear multicast */
drivers/net/ethernet/xilinx/xilinx_axienet.h:179:#define XAE_RAF_MCSTREJ_MASK		0x00000002 /* Reject receive multicast
drivers/net/ethernet/xilinx/xilinx_axienet.h:324:					   * hardware multicast table. */
drivers/net/ethernet/8390/8390.h:118:#define E8390_RXCONFIG		0x4	/* EN0_RXCR: broadcasts, no multicast,errors */
drivers/net/ethernet/8390/8390.h:203:#define EN1_MULT_SHIFT(i)  EI_SHIFT(8+i) /* Get and set multicast filter */
drivers/net/ethernet/8390/8390.h:211:#define ENRSR_PHY	0x20	/* physical/multicast address */
drivers/net/ethernet/8390/axnet_cs.c:769:  Alexey Kuznetsov	: use the 8390's six bit hash multicast filter.
drivers/net/ethernet/8390/axnet_cs.c:770:  Paul Gortmaker	: tweak ANK's above multicast changes a bit.
drivers/net/ethernet/8390/axnet_cs.c:839: *	processor case other than interrupts (get stats/set multicast list in
drivers/net/ethernet/8390/axnet_cs.c:1413:					dev->stats.multicast++;
drivers/net/ethernet/8390/axnet_cs.c:1540: * Form the 64 bit 8390 multicast table from the linked list of addresses
drivers/net/ethernet/8390/axnet_cs.c:1553:		 * CRC to index the multicast table.
drivers/net/ethernet/8390/axnet_cs.c:1560: * do_set_multicast_list - set/clear multicast filter
drivers/net/ethernet/8390/axnet_cs.c:1561: * @dev: net device for which multicast filter is adjusted
drivers/net/ethernet/8390/axnet_cs.c:1563: *	Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/8390/lib8390.c:35:  Alexey Kuznetsov	: use the 8390's six bit hash multicast filter.
drivers/net/ethernet/8390/lib8390.c:36:  Paul Gortmaker	: tweak ANK's above multicast changes a bit.
drivers/net/ethernet/8390/lib8390.c:132: *	processor case other than interrupts (get stats/set multicast list in
drivers/net/ethernet/8390/lib8390.c:740:					dev->stats.multicast++;
drivers/net/ethernet/8390/lib8390.c:871: * Form the 64 bit 8390 multicast table from the linked list of addresses
drivers/net/ethernet/8390/lib8390.c:883:		 * CRC to index the multicast table.
drivers/net/ethernet/8390/lib8390.c:890: * do_set_multicast_list - set/clear multicast filter
drivers/net/ethernet/8390/lib8390.c:891: * @dev: net device for which multicast filter is adjusted
drivers/net/ethernet/8390/lib8390.c:893: *	Set or clear the multicast filter for this adaptor. May be called
drivers/net/ethernet/8390/lib8390.c:912:	 * the multicast regs on an already running card. To be safe, we
drivers/net/ethernet/8390/lib8390.c:913:	 * ensure multicast mode is off prior to loading up the new hash
drivers/net/ethernet/korina.c:382:			dev->stats.multicast++;
drivers/net/ethernet/korina.c:416:				dev->stats.multicast++;
drivers/net/ethernet/korina.c:477: * Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/korina.c:491:		/* All multicast and broadcast */
drivers/net/ethernet/korina.c:504:		/* Accept filtered multicast */
drivers/net/ethernet/toshiba/ps3_gelic_net.c:599: * gelic_net_set_multi - sets multicast addresses and promisc flags
drivers/net/ethernet/toshiba/ps3_gelic_net.c:602: * gelic_net_set_multi configures multicast addresses as needed for the
drivers/net/ethernet/toshiba/ps3_gelic_net.c:603: * netdev interface. It also sets up multicast, allmulti and promisc
drivers/net/ethernet/toshiba/ps3_gelic_net.c:615:	/* clear all multicast address */
drivers/net/ethernet/toshiba/ps3_gelic_net.c:642:	/* set multicast addresses */
drivers/net/ethernet/toshiba/ps3_gelic_net.c:1203: * operation, sets up multicast list and enables interrupts
drivers/net/ethernet/toshiba/spider_net.c:588: * spider_net_get_multicast_hash - generates hash for multicast filter table
drivers/net/ethernet/toshiba/spider_net.c:589: * @addr: multicast address
drivers/net/ethernet/toshiba/spider_net.c:593: * spider_net_get_multicast_hash calculates a hash value for a given multicast
drivers/net/ethernet/toshiba/spider_net.c:594: * address, that is used to set the multicast filter tables
drivers/net/ethernet/toshiba/spider_net.c:620: * spider_net_set_multi - sets multicast addresses and promisc flags
drivers/net/ethernet/toshiba/spider_net.c:623: * spider_net_set_multi configures multicast addresses as needed for the
drivers/net/ethernet/toshiba/spider_net.c:624: * netdev interface. It also sets up multicast, allmulti and promisc
drivers/net/ethernet/toshiba/spider_net.c:1964: * operation, sets up multicast list and enables interrupts
drivers/net/ethernet/toshiba/ps3_gelic_net.h:42:#define GELIC_NET_MC_COUNT_MAX          32 /* multicast address list */
drivers/net/ethernet/toshiba/ps3_gelic_net.h:120:	GELIC_DESCR_RXMLTCST	= 0x00004000, /* multicast address frame */
drivers/net/ethernet/toshiba/tc35815.c:1917: * Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/toshiba/tc35815.c:1919: * num_addrs == 0	Normal mode, clear multicast list
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:50:	"multicast",
drivers/net/ethernet/brocade/bna/bna_tx_rx.c:444:/* This function gets the multicast MAC that has already been added to CAM */
drivers/net/ethernet/brocade/bna/bna_tx_rx.c:532:	/* First delete multicast entries to maintain the count */
drivers/net/ethernet/brocade/bna/bna_tx_rx.c:543:	/* Add multicast entries */
drivers/net/ethernet/brocade/bna/bnad.c:2455:	stats->multicast = mac_stats->rx_multicast;
drivers/net/ethernet/brocade/bna/bna_types.h:768:	/* List of multicast addresses yet to be applied to h/w */
drivers/net/ethernet/brocade/bna/bna_types.h:771:	/* multicast addresses applied to the h/w */
drivers/net/ethernet/brocade/bna/bfa_defs_cna.h:71:	u64	tx_mcast_packets; /*!< Tx multicast packets	*/
drivers/net/ethernet/brocade/bna/bfa_defs_cna.h:80:	u64	rx_mcast_packets; /*!< Rx multicast packets	*/
drivers/net/ethernet/emulex/benet/be_main.c:600:		stats->multicast += rx_stats(rxo)->rx_mcast_pkts;
drivers/net/ethernet/emulex/benet/be_main.c:1200:	/* Enable multicast promisc if num configured exceeds what we support */
drivers/net/ethernet/emulex/benet/be_main.c:1234:		dev_info(&adapter->pdev->dev, "Exhausted multicast HW filters.\n");
drivers/net/ethernet/emulex/benet/be_main.c:1235:		dev_info(&adapter->pdev->dev, "Disabling HW multicast filtering.\n");
drivers/net/ethernet/emulex/benet/be_ethtool.c:55:	 * multicast address filtering.
drivers/net/ethernet/3com/3c59x.c:3021:/* Pre-Cyclone chips have no documented multicast filter, so the only
drivers/net/ethernet/3com/3c59x.c:3022:   multicast setting is to receive all multicast frames.  At least
drivers/net/ethernet/3com/typhoon.c:58:/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).
drivers/net/ethernet/3com/3c509.c:976: *     Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/3com/3c515.c:1521:   The Vortex chip has no documented multicast filter, so the only
drivers/net/ethernet/3com/3c515.c:1522:   multicast setting is to receive all multicast frames.  At least
drivers/net/ethernet/3com/3c574_cs.c:1085:/* The Odie chip has a 64 bin multicast filter, but the bit layout is not
drivers/net/ethernet/3com/3c574_cs.c:1086:   documented.  Until it is we revert to receiving all multicast frames when
drivers/net/ethernet/3com/3c574_cs.c:1087:   any multicast reception is desired.
drivers/net/ethernet/faraday/ftgmac100.c:447:		netdev->stats.multicast++;
drivers/net/ethernet/faraday/ftmac100.c:433:		netdev->stats.multicast++;
drivers/net/ethernet/dnet.c:757:	nstat->multicast = hwstat->rx_multicast;
drivers/net/ethernet/dlink/dl2k.c:991:	np->stats.multicast = dr32(McstFramesRcvdOk);
drivers/net/ethernet/dlink/dl2k.c:1122:		/* Receive broadcast and multicast frames */
drivers/net/ethernet/dlink/dl2k.c:1126:		/* Receive broadcast frames and multicast frames filtering
drivers/net/ethernet/dlink/sundance.c:33:/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).
drivers/net/ethernet/dlink/sundance.c:410:	spinlock_t mcastlock;			/* SMP lock multicast updates. */
drivers/net/ethernet/tehuti/tehuti.c:798:		/* set IMF to accept all multicast frmaes */
drivers/net/ethernet/tehuti/tehuti.c:806:		/* set IMF to deny all multicast frames */
drivers/net/ethernet/tehuti/tehuti.c:809:		/* set PMF to deny all multicast frames */
drivers/net/ethernet/tehuti/tehuti.c:818:		 * multicast frames throu IMF */
drivers/net/ethernet/tehuti/tehuti.c:2056:		 * set multicast list callback has to use priv->tx_lock.
drivers/net/ethernet/tehuti/tehuti.h:502:#define  GMAC_RX_FILTER_AM    0x0008	/* accept multicast */
drivers/net/ethernet/cadence/at91_ether.c:211:			lp->stats.multicast++;
drivers/net/ethernet/cadence/macb.c:1424: * The unicast hash enable and the multicast hash enable bits in the
drivers/net/ethernet/cadence/macb.c:1439: * received, that is, the multicast/unicast indicator, and da[47]
drivers/net/ethernet/cadence/macb.c:1443: * frame is multicast or unicast.  A multicast match will be signalled
drivers/net/ethernet/cadence/macb.c:1444: * if the multicast hash enable bit is set, da[0] is 1 and the hash
drivers/net/ethernet/cadence/macb.c:1448: * receive all multicast frames, the hash register should be set with
drivers/net/ethernet/cadence/macb.c:1449: * all ones and the multicast hash enable bit should be set in the
drivers/net/ethernet/cadence/macb.c:1479: * Add multicast addresses to the internal multicast-hash table.
drivers/net/ethernet/cadence/macb.c:1500: * Enable/Disable promiscuous and multicast modes.
drivers/net/ethernet/cadence/macb.c:1517:		/* Enable all multicast mode */
drivers/net/ethernet/cadence/macb.c:1526:		/* Disable all multicast mode */
drivers/net/ethernet/cadence/macb.c:1624:	nstat->multicast = hwstat->rx_multicast_frames;
drivers/net/ethernet/qlogic/qlge/qlge.h:1764:	 * 2 cam words for each of 32 multicast.
drivers/net/ethernet/qlogic/qlge/qlge.h:1909:	 * 2 cam words for each of 32 multicast.
drivers/net/ethernet/qlogic/qlge/qlge_main.c:330:/* Set up a MAC, multicast or VLAN address for the
drivers/net/ethernet/qlogic/qlge/qlge_main.c:517: * multicast/error frames to the default queue for slow handling,
drivers/net/ethernet/qlogic/qlge/qlge_main.c:3481:				 * broadcast/multicast, fatal errors,
drivers/net/ethernet/qlogic/qlge/qlge_main.c:4313:	ndev->stats.multicast = mcast;
drivers/net/ethernet/qlogic/qlge/qlge_main.c:4364:	 * Set or clear all multicast mode if a
drivers/net/ethernet/qlogic/qlge/qlge_main.c:4409:				  "Failed to set multicast match mode.\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:61:	"tx multicast frames",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:68:	"rx multicast frames",
drivers/net/ethernet/qlogic/qlcnic/qlcnic.h:856:#define VPORT_MISS_MODE_ACCEPT_MULTI	2 /* accept unmatched multicast */
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:1011:		/* Initialize multicast addr pool owners */
drivers/net/ethernet/qlogic/netxen/netxen_nic.h:1056:#define VPORT_MISS_MODE_ACCEPT_MULTI	2 /* accept unmatched multicast */
drivers/net/ethernet/davicom/dm9000.c:836: *  Set DM9000 multicast address
drivers/net/ethernet/davicom/dm9000.c:859:	/* the multicast address in Hash Table : 64 bits */
drivers/net/ethernet/sfc/rx.c:950: * efx_filter_is_mc_recipient - test whether spec is a multicast recipient
drivers/net/ethernet/sfc/rx.c:955: * IPv4 or IPv6 address value in the respective multicast address
drivers/net/ethernet/sfc/net_driver.h:395: * @n_rx_mcast_mismatch: Count of unmatched multicast frames
drivers/net/ethernet/sfc/net_driver.h:632:/* Number of bits used in a multicast filter hash address */
drivers/net/ethernet/sfc/net_driver.h:635:/* Number of (single-bit) entries in a multicast filter hash */
drivers/net/ethernet/sfc/net_driver.h:638:/* An Efx multicast filter hash */
drivers/net/ethernet/sfc/net_driver.h:744: * @mac_work: Work item for changing MAC promiscuity and multicast hash
drivers/net/ethernet/sfc/filter.h:30: *	Used for RX default unicast and multicast/broadcast filters.
drivers/net/ethernet/sfc/filter.h:262: * efx_filter_set_mc_def - specify matching otherwise-unmatched multicast
drivers/net/ethernet/sfc/siena.c:558:		core_stats->multicast = stats[SIENA_STAT_rx_multicast];
drivers/net/ethernet/sfc/ef10.c:991:		core_stats->multicast = stats[EF10_STAT_rx_multicast];
drivers/net/ethernet/sfc/ef10.c:2452:	/* Mark lower-priority multicast recipients busy prior to removal */
drivers/net/ethernet/sfc/ef10.c:2489:	/* Remove and finalise entries for lower-priority multicast
drivers/net/ethernet/sfc/ef10.c:2767:	/* Must be an RX filter without RSS and not for a multicast
drivers/net/ethernet/sfc/ef10.c:3214:	/* Insert/renew multicast filters */
drivers/net/ethernet/sfc/ef10.c:3224:				/* Fall back to multicast-promisc */
drivers/net/ethernet/sfc/efx.h:96: * This implies that filters for multiple multicast recipients must
drivers/net/ethernet/sfc/farch.c:955: * Also "is multicast" and "matches multicast filter" flags can be used to
drivers/net/ethernet/sfc/farch.c:956: * discard non-matching multicast packets.
drivers/net/ethernet/sfc/farch.c:1043:	/* Detect multicast packets that didn't match the filter */
drivers/net/ethernet/sfc/farch.c:2917:	/* Build multicast hash table */
drivers/net/ethernet/sfc/farch.c:2928:		/* Broadcast packets go through the multicast hash filter.
drivers/net/ethernet/sfc/falcon.c:1380:	/* Restore the multicast hash registers. */
drivers/net/ethernet/sfc/falcon.c:2587:		core_stats->multicast = stats[FALCON_STAT_rx_multicast];
drivers/net/ethernet/sfc/efx.c:989:/* Asynchronous work item for changing MAC promiscuity and multicast
drivers/net/ethernet/dec/tulip/de2104x.c:659:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/dec/tulip/de2104x.c:744:	if (netdev_mc_count(dev) > 14)	/* Must use a multicast hash table. */
drivers/net/ethernet/dec/tulip/winbond-840.c:71:/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
drivers/net/ethernet/dec/tulip/winbond-840.c:162:MODULE_PARM_DESC(multicast_filter_limit, "winbond-840 maximum number of filtered multicast addresses");
drivers/net/ethernet/dec/tulip/winbond-840.c:183:A significant difference is that the multicast filter and station address are
drivers/net/ethernet/dec/tulip/dmfe.c:1052: * Set DM910X multicast address
drivers/net/ethernet/dec/tulip/dmfe.c:1073:		DMFE_DBUG(0, "Pass all multicast address", mc_count);
drivers/net/ethernet/dec/tulip/dmfe.c:1080:	DMFE_DBUG(0, "Set multicast address", mc_count);
drivers/net/ethernet/dec/tulip/dmfe.c:1477:	/* the multicast address in Hash Table : 64 bits */
drivers/net/ethernet/dec/tulip/dmfe.c:1520:	/* fit the multicast address */
drivers/net/ethernet/dec/tulip/tulip_core.c:1008:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/dec/tulip/tulip_core.c:1134:			/* Must use a multicast hash table. */
drivers/net/ethernet/dec/tulip/de4x5.c:304:			  Change all chips to use perfect multicast filtering.
drivers/net/ethernet/dec/tulip/de4x5.c:776:	u_int multicast;
drivers/net/ethernet/dec/tulip/de4x5.c:1363:** see why I'd want > 14 multicast addresses, I have changed all chips to use
drivers/net/ethernet/dec/tulip/de4x5.c:1875:	    lp->pktStats.multicast++;
drivers/net/ethernet/dec/tulip/de4x5.c:1914:** Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/dec/tulip/de4x5.c:1943:** from a list of ethernet multicast addresses.
drivers/net/ethernet/dec/tulip/de4x5.c:5417:    case DE4X5_MCA_EN:               /* Enable pass all multicast addressing */
drivers/net/ethernet/dec/tulip/uli526x.c:895: * Set ULI526X multicast address
drivers/net/ethernet/dec/tulip/uli526x.c:916:		ULI526X_DBUG(0, "Pass all multicast address",
drivers/net/ethernet/dec/tulip/uli526x.c:924:	ULI526X_DBUG(0, "Set multicast address", netdev_mc_count(dev));
drivers/net/ethernet/dec/tulip/uli526x.c:1408:	/* fit the multicast address */
drivers/net/ethernet/dec/tulip/tulip.h:57:	MC_HASH_ONLY		= 0x00020, /* Hash-only multicast filter. */
drivers/net/ethernet/dec/tulip/de4x5.h:888:#define HASH_PERF            1     /* 1 perfect, 512 multicast addresses */
drivers/net/ethernet/dec/tulip/de4x5.h:890:#define ALL_HASH             3     /* Hashes all physical & multicast addrs */
drivers/net/ethernet/dec/tulip/de4x5.h:1007:#define DE4X5_GET_MCA   	0x06 /* Get a multicast address */
drivers/net/ethernet/dec/tulip/de4x5.h:1008:#define DE4X5_SET_MCA   	0x07 /* Set a multicast address */
drivers/net/ethernet/dec/tulip/de4x5.h:1009:#define DE4X5_CLR_MCA    	0x08 /* Clear a multicast address */
drivers/net/ethernet/dec/tulip/de4x5.h:1010:#define DE4X5_MCA_EN    	0x09 /* Enable a multicast address group */
drivers/net/ethernet/broadcom/tg3.c:9666:	/* accept or reject all multicast frames */
drivers/net/ethernet/broadcom/tg3.c:9693:		/* Accept all multicast. */
drivers/net/ethernet/broadcom/tg3.c:9696:		/* Reject all multicast. */
drivers/net/ethernet/broadcom/tg3.c:9699:		/* Accept one or more multicast(s). */
drivers/net/ethernet/broadcom/tg3.c:11846:	stats->multicast = old_stats->multicast +
drivers/net/ethernet/broadcom/bgmac.c:914:		/* TODO: Clear software multicast filter list */
drivers/net/ethernet/broadcom/bnx2.c:3591:		/* Accept one or more multicast(s). */
drivers/net/ethernet/broadcom/bnx2.c:3977:		/* receive all multicast */
drivers/net/ethernet/broadcom/bnx2.c:6819:	net_stats->multicast =
drivers/net/ethernet/broadcom/bcm63xx_enet.c:684: * Change rx mode (promiscuous/allmulti) and update multicast list
drivers/net/ethernet/broadcom/bcm63xx_enet.c:710:	 * multicast */
drivers/net/ethernet/broadcom/b44.c:1700:		nstat->multicast  = hwstat->tx_multicast_pkts;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:2830:	/* RESTORE command will restore the entire multicast configuration */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:3063:/* On 57711 we write the multicast MACs' approximate match
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:3081:		/* Set the multicast filter bits before writing it into
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:3091:			   "Invalidating multicast MACs configuration\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:3134:	/* RESTORE command will restore the entire multicast configuration */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:3148:			BNX2X_ERR("Can't configure more than %d multicast MACs on 57710\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:3315:		DP(BNX2X_MSG_SP, "About to delete %d multicast MACs\n", cnt);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.h:301:	u8  multicast[PFVF_MAX_MULTICAST_PER_VF][ETH_ALEN];
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:502:/********************** Set multicast group ***********************************/
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:1349: * bnx2x_config_mcast - Configure multicast MACs list.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h:1067:	/* multicast configuration controlling object */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c:1003:		 * unicast/multicast/broadcast
drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c:1054:		 * unicast/multicast/broadcast
drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c:1175:	nstats->multicast =
drivers/net/ethernet/broadcom/bnx2x/bnx2x_fw_defs.h:282:/*The CRC32 seed, that is used for the hash(reduction) multicast address */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c:843:		memcpy(req->multicast[i], bnx2x_mc_addr(ha), ETH_ALEN);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c:852:		   "VF supports not more than %d multicast MAC addresses\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c:874:		BNX2X_ERR("Set Rx mode/multicast failed: %d\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c:1426:			/* rx setup - multicast engine */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c:1527:			DP(msglvl, "MULTICAST=%pM\n", filters->multicast[i]);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c:1660:			rc = bnx2x_vfop_mcast_cmd(bp, vf, &cmd, msg->multicast,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_hsi.h:3957:/*Command for setting multicast classification for a client */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_hsi.h:3976: * parameters for multicast classification ramrod
drivers/net/ethernet/broadcom/bnx2x/bnx2x_hsi.h:4530: * approximate-match multicast filtering for E1H per function in Tstorm
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:5035:		/* This is only relevant for 57710 where multicast MACs are
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:8940:	/* Cleanup multicast configuration */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:8944:		BNX2X_ERR("Failed to send DEL multicast command: %d\n", rc);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:12028:	/* first, clear all configured multicast MACs */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:12031:		BNX2X_ERR("Failed to clear multicast configuration: %d\n", rc);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:12039:			BNX2X_ERR("Failed to create multicast MACs list: %d\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:12048:			BNX2X_ERR("Failed to set a new multicast configuration: %d\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:13617:		 * function will receive multicast packets (leading in our
drivers/net/ethernet/broadcom/sb1250-mac.c:1590:	 * Program multicast addresses
drivers/net/ethernet/broadcom/sb1250-mac.c:2074: *  Reprogram the multicast table into the hardware, given
drivers/net/ethernet/broadcom/sb1250-mac.c:2094:	 * Clear out entire multicast table.  We do this by nuking
drivers/net/ethernet/broadcom/sb1250-mac.c:2120:		 * multicast enable bit.
drivers/net/ethernet/broadcom/sb1250-mac.c:2130:	 * Progam new multicast entries.  For now, only use the
drivers/net/ethernet/broadcom/sb1250-mac.c:2149:	 * Enable the "accept multicast bits" if we programmed at least one
drivers/net/ethernet/broadcom/sb1250-mac.c:2150:	 * multicast.
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe.h:537: * @multicast:		    multicast packets received
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe.h:564:	u32 multicast;
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c:50:	PCH_GBE_STAT(multicast),
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:427: * @mc_addr_list:   Array of multicast addresses to program
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:428: * @mc_addr_count:  Number of multicast addresses to program
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:438:	/* Load the first set of multicast addresses into the exact
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:772:	/* reprogram multicast address register after reset */
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:1295:	netdev->stats.multicast = stats->multicast;
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:1747:				adapter->stats.multicast++;
drivers/net/ethernet/pasemi/pasemi_mac_ethtool.c:35:	{ "rx-multicast-packets" },
drivers/net/ethernet/pasemi/pasemi_mac_ethtool.c:51:	{ "tx-multicast-packets" },
drivers/net/ethernet/natsemi/sonic.c:525: * Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/natsemi/ns83820.c:899:				ndev->stats.multicast++;
drivers/net/ethernet/natsemi/natsemi.c:76:/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).
drivers/net/ethernet/nxp/lpc_eth.c:1184:	/* 64 bits : multicast address in hash table */
drivers/net/ethernet/cisco/enic/enic_dev.h:46:int enic_dev_packet_filter(struct enic *enic, int directed, int multicast,
drivers/net/ethernet/cisco/enic/enic_main.c:581:	net_stats->multicast = stats->rx.rx_multicast_frames_ok;
drivers/net/ethernet/cisco/enic/enic_main.c:667:			"multicast addresses\n",
drivers/net/ethernet/cisco/enic/enic_main.c:673:	 * calls to add/del multicast addrs.  We keep the
drivers/net/ethernet/cisco/enic/enic_main.c:768:	int multicast = (netdev->flags & IFF_MULTICAST) ? 1 : 0;
drivers/net/ethernet/cisco/enic/enic_main.c:781:			multicast, broadcast, promisc, allmulti);
drivers/net/ethernet/cisco/enic/vnic_dev.c:640:int vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,
drivers/net/ethernet/cisco/enic/vnic_dev.c:648:	     (multicast ? CMD_PFILTER_MULTICAST : 0) |
drivers/net/ethernet/cisco/enic/enic_dev.c:78:int enic_dev_packet_filter(struct enic *enic, int directed, int multicast,
drivers/net/ethernet/cisco/enic/enic_dev.c:85:		multicast, broadcast, promisc, allmulti);
drivers/net/ethernet/cisco/enic/vnic_dev.h:96:int vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,
drivers/net/ethernet/nvidia/forcedeth.c:1781:		storage->multicast = np->estats.rx_multicast;
drivers/net/ethernet/silan/sc92031.c:44:/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast). */
drivers/net/ethernet/silan/sc92031.c:48:	"Maximum number of filtered multicast addresses");
drivers/net/ethernet/silan/sc92031.c:613:	/* clear multicast address */
drivers/net/ethernet/silan/sc92031.c:813:			dev->stats.multicast++;
drivers/net/ethernet/intel/igb/igb.h:113:#define IGB_VF_FLAG_MULTI_PROMISC  0x00000004 /* VF has multicast promisc */
drivers/net/ethernet/intel/igb/e1000_mac.c:281:	/* if multicast bit is set, the alternate address will not be used */
drivers/net/ethernet/intel/igb/e1000_mac.c:334: *  igb_mta_set - Set multicast filter table address
drivers/net/ethernet/intel/igb/e1000_mac.c:338: *  The multicast table address is a register array of 32-bit registers.
drivers/net/ethernet/intel/igb/e1000_mac.c:368: *  igb_hash_mc_addr - Generate a multicast hash value
drivers/net/ethernet/intel/igb/e1000_mac.c:370: *  @mc_addr: pointer to a multicast address
drivers/net/ethernet/intel/igb/e1000_mac.c:372: *  Generates a multicast address hash value which is used to determine
drivers/net/ethernet/intel/igb/e1000_mac.c:373: *  the multicast filter table array address and new table value.  See
drivers/net/ethernet/intel/igb/e1000_mac.c:439: *  @mc_addr_list: array of multicast addresses to program
drivers/net/ethernet/intel/igb/e1000_mac.c:440: *  @mc_addr_count: number of multicast addresses to program
drivers/net/ethernet/intel/igb/e1000_mac.c:443: *  The caller must have a packed mc_addr_list of multicast addresses.
drivers/net/ethernet/intel/igb/e1000_defines.h:130:#define E1000_RCTL_MPE            0x00000010    /* multicast promiscuous enab */
drivers/net/ethernet/intel/igb/e1000_defines.h:135:#define E1000_RCTL_MO_SHIFT       12            /* multicast offset shift */
drivers/net/ethernet/intel/igb/e1000_defines.h:456: * Registers) holds the directed and multicast addresses that we monitor.
drivers/net/ethernet/intel/igb/e1000_defines.h:459: * manageability enabled, allowing us room for 15 multicast addresses.
drivers/net/ethernet/intel/igb/igb_ethtool.c:65:	IGB_STAT("multicast", stats.mprc),
drivers/net/ethernet/intel/igb/igb_main.c:3533:	 * multicast packets
drivers/net/ethernet/intel/igb/igb_main.c:3840: *  igb_write_mc_addr_list - write multicast addresses to MTA
drivers/net/ethernet/intel/igb/igb_main.c:3843: *  Writes multicast address list to the MTA hash table.
drivers/net/ethernet/intel/igb/igb_main.c:3925: *  The set_rx_mode entry point is called whenever the unicast or multicast
drivers/net/ethernet/intel/igb/igb_main.c:3927: *  responsible for configuring the hardware for proper unicast, multicast,
drivers/net/ethernet/intel/igb/igb_main.c:3957:			 * that we can at least receive multicast traffic
drivers/net/ethernet/intel/igb/igb_main.c:5248:	net_stats->multicast = adapter->stats.mprc;
drivers/net/ethernet/intel/igb/igb_main.c:5548:		/* if we have hashes and we are clearing a multicast promisc
drivers/net/ethernet/intel/igb/igb_main.c:5579:	/* salt away the number of multicast addresses assigned
drivers/net/ethernet/intel/igb/igb_main.c:5880:	/* reset multicast table array for vf */
drivers/net/ethernet/intel/igb/igb_main.c:7334:		/* turn on all-multi mode if wake on multicast is enabled */
drivers/net/ethernet/intel/igb/e1000_82575.h:227:#define E1000_VMOLR_ROMPE      0x02000000 /* Accept overflow multicast */
drivers/net/ethernet/intel/ixgbevf/ethtool.c:82:	{"multicast", IXGBEVF_STAT(stats.vfmprc, stats.base_vfmprc,
drivers/net/ethernet/intel/ixgbevf/vf.c:36: *  all on chip counters, initializes receive address registers, multicast
drivers/net/ethernet/intel/ixgbevf/vf.c:179: *  ixgbevf_mta_vector - Determines bit-vector in multicast table to set
drivers/net/ethernet/intel/ixgbevf/vf.c:181: *  @mc_addr: the multicast address
drivers/net/ethernet/intel/ixgbevf/vf.c:183: *  Extracts the 12 bits, from a multicast address, to determine which
drivers/net/ethernet/intel/ixgbevf/vf.c:184: *  bit-vector to set in the multicast table. The hardware uses 12 bits, from
drivers/net/ethernet/intel/ixgbevf/vf.c:185: *  incoming rx multicast addresses, to determine the bit-vector to check in
drivers/net/ethernet/intel/ixgbevf/vf.h:43:/* iterator type for walking multicast address lists */
drivers/net/ethernet/intel/ixgbevf/mbx.h:115:/* word in permanent address message with the current multicast type */
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:516:		/* Workaround hardware that can't do proper VEPA multicast
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:1443: * The set_rx_method entry point is called whenever the multicast address
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:1446: * multicast mode and configuring requested unicast filters.
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:1455:	/* reprogram multicast list */
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:3342:	stats->multicast = adapter->stats.vfmprc - adapter->stats.base_vfmprc;
drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h:252: * VF sends this message in order to add one or more unicast or multicast
drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h:258: * VF sends this message in order to remove one or more unicast or multicast
drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c:612: * @flags: bitmask to control unicast/multicast promiscuous.
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:1085:/* Add multicast E-Tag (direct 0x0257)
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:1086: * del multicast E-Tag (direct 0x0258) only uses pv_seid and etag fields
drivers/net/ethernet/intel/igbvf/ethtool.c:57:	{ "multicast", IGBVF_STAT(stats.mprc, stats.base_mprc) },
drivers/net/ethernet/intel/igbvf/netdev.c:1401: * The set_multi entry point is called whenever the multicast address
drivers/net/ethernet/intel/igbvf/netdev.c:1403: * responsible for configuring the hardware for proper multicast,
drivers/net/ethernet/intel/igbvf/netdev.c:1799:	adapter->net_stats.multicast = adapter->stats.mprc;
drivers/net/ethernet/intel/igbvf/vf.c:65:	/* multicast address update */
drivers/net/ethernet/intel/igbvf/vf.c:181: *  e1000_hash_mc_addr_vf - Generate a multicast hash value
drivers/net/ethernet/intel/igbvf/vf.c:183: *  @mc_addr: pointer to a multicast address
drivers/net/ethernet/intel/igbvf/vf.c:185: *  Generates a multicast address hash value which is used to determine
drivers/net/ethernet/intel/igbvf/vf.c:186: *  the multicast filter table array address and new table value.  See
drivers/net/ethernet/intel/igbvf/vf.c:213: *  @mc_addr_list: array of multicast addresses to program
drivers/net/ethernet/intel/igbvf/vf.c:214: *  @mc_addr_count: number of multicast addresses to program
drivers/net/ethernet/intel/igbvf/vf.c:219: *  The caller must have a packed mc_addr_list of multicast addresses.
drivers/net/ethernet/intel/igbvf/vf.h:55: * Registers) holds the directed and multicast addresses that we monitor.
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:1254:#define IXGBE_VMOLR_MPE         0x10000000 /* multicast promiscuous */
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:2823:/* iterator type for walking multicast address lists */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:1274:	 * clear the multicast table.  Also reset num_rar_entries to 128,
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:278: *  all on chip counters, initializes receive address registers, multicast
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:358: *  address registers, multicast table, VLAN filter table, calls routine to set
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:1905: *  of the receive address registers. Clears the multicast table. Assumes
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:1959: *  ixgbe_mta_vector - Determines bit-vector in multicast table to set
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:1961: *  @mc_addr: the multicast address
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:1963: *  Extracts the 12 bits, from a multicast address, to determine which
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:1964: *  bit-vector to set in the multicast table. The hardware uses 12 bits, from
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:1965: *  incoming rx multicast addresses, to determine the bit-vector to check in
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:1998: *  ixgbe_set_mta - Set bit-vector in multicast table
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2002: *  Sets the bit-vector in the multicast table.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2030: *  ixgbe_update_mc_addr_list_generic - Updates MAC list of multicast addresses
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2035: *  address registers and the multicast table. Uses unused receive address
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2036: *  registers for the first multicast addresses, and hashes the rest into the
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2037: *  multicast table.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2058:		hw_dbg(hw, " Adding the multicast addresses:\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2076: *  ixgbe_enable_mc_generic - Enable multicast address in RAR
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2079: *  Enables multicast address in RAR and the use of the multicast hash table.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2093: *  ixgbe_disable_mc_generic - Disable multicast address in RAR
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:2096: *  Disables multicast address in RAR and the use of the multicast hash table.
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:144:	 * clear the multicast table.  Also reset num_rar_entries to 128,
drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h:101:/* word in permanent address message with the current multicast type */
drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c:79:	{"multicast", IXGBE_NETDEV_STAT(multicast)},
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c:831:	 * clear the multicast table
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:3834: * The set_rx_method entry point is called whenever the unicast/multicast
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:3836: * responsible for configuring the hardware for proper unicast, multicast and
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:3894:	 * that we can at least receive multicast traffic
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:5582:		/* turn on all-multi mode if wake on multicast is enabled */
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:5855:	netdev->stats.multicast = hwstats->mprc;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:7263:	stats->multicast	= netdev->stats.multicast;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:341:	 * VFs are limited to using the MTA hash table for their multicast
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:540:	/* reset multicast table array for vf */
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:723:	 * Piggyback the multicast filter type so VF can compute the
drivers/net/ethernet/intel/e1000e/ethtool.c:74:	E1000_STAT("multicast", stats.mprc),
drivers/net/ethernet/intel/e1000e/netdev.c:3241: * e1000e_write_mc_addr_list - write multicast addresses to MTA
drivers/net/ethernet/intel/e1000e/netdev.c:3244: * Writes multicast address list to the MTA hash table.
drivers/net/ethernet/intel/e1000e/netdev.c:3333: * The ndo_set_rx_mode entry point is called whenever the unicast or multicast
drivers/net/ethernet/intel/e1000e/netdev.c:3335: * responsible for configuring the hardware for proper unicast, multicast,
drivers/net/ethernet/intel/e1000e/netdev.c:3362:			 * that we can at least receive multicast traffic
drivers/net/ethernet/intel/e1000e/netdev.c:4647:	netdev->stats.multicast = adapter->stats.mprc;
drivers/net/ethernet/intel/e1000e/netdev.c:5629:	stats->multicast = adapter->stats.mprc;
drivers/net/ethernet/intel/e1000e/netdev.c:5963:		/* turn on all-multi mode if wake on multicast is enabled */
drivers/net/ethernet/intel/e1000e/defines.h:142:#define E1000_RCTL_MPE            0x00000010    /* multicast promiscuous enab */
drivers/net/ethernet/intel/e1000e/defines.h:149:#define E1000_RCTL_MO_SHIFT       12            /* multicast offset shift */
drivers/net/ethernet/intel/e1000e/defines.h:150:#define E1000_RCTL_MO_3           0x00003000    /* multicast offset 15:4 */
drivers/net/ethernet/intel/e1000e/defines.h:474: * Registers) holds the directed and multicast addresses that we monitor.
drivers/net/ethernet/intel/e1000e/defines.h:477: * manageability enabled, allowing us room for 15 multicast addresses.
drivers/net/ethernet/intel/e1000e/mac.c:206:	/* if multicast bit is set, the alternate address will not be used */
drivers/net/ethernet/intel/e1000e/mac.c:257: *  e1000_hash_mc_addr - Generate a multicast hash value
drivers/net/ethernet/intel/e1000e/mac.c:259: *  @mc_addr: pointer to a multicast address
drivers/net/ethernet/intel/e1000e/mac.c:261: *  Generates a multicast address hash value which is used to determine
drivers/net/ethernet/intel/e1000e/mac.c:262: *  the multicast filter table array address and new table value.
drivers/net/ethernet/intel/e1000e/mac.c:327: *  @mc_addr_list: array of multicast addresses to program
drivers/net/ethernet/intel/e1000e/mac.c:328: *  @mc_addr_count: number of multicast addresses to program
drivers/net/ethernet/intel/e1000e/mac.c:331: *  The caller must have a packed mc_addr_list of multicast addresses.
drivers/net/ethernet/intel/e100.c:83: *	Non-Tx commands (config, multicast setup, etc) are linked
drivers/net/ethernet/intel/e100.c:1751:		/* Issue a multicast command to workaround a 557 lock up */
drivers/net/ethernet/intel/e100.c:2689:	"tx_errors", "rx_dropped", "tx_dropped", "multicast", "collisions",
drivers/net/ethernet/intel/e1000/e1000_hw.c:557: * multicast table, and VLAN filter table. Calls routines to setup link
drivers/net/ethernet/intel/e1000/e1000_hw.c:4389: * of the receive address registers. Clears the multicast table. Assumes
drivers/net/ethernet/intel/e1000/e1000_hw.c:4417: * e1000_hash_mc_addr - Hashes an address to determine its location in the multicast table
drivers/net/ethernet/intel/e1000/e1000_hw.c:4419: * @mc_addr: the multicast address to hash
drivers/net/ethernet/intel/e1000/e1000_hw.c:4985:	/* Is this a broadcast or multicast?  Check broadcast first,
drivers/net/ethernet/intel/e1000/e1000_hw.c:4986:	 * since the test for a multicast frame will test positive on
drivers/net/ethernet/intel/e1000/e1000_main.c:2212: * The set_rx_mode entry point is called whenever the unicast or multicast
drivers/net/ethernet/intel/e1000/e1000_main.c:2214: * responsible for configuring the hardware for proper unicast, multicast,
drivers/net/ethernet/intel/e1000/e1000_main.c:3680:	netdev->stats.multicast = adapter->stats.mprc;
drivers/net/ethernet/intel/e1000/e1000_main.c:4980:		/* turn on all-multi mode if wake on multicast is enabled */
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:62:	{ "multicast", E1000_STAT(stats.mprc) },
drivers/net/ethernet/intel/e1000/e1000_hw.h:378:/* Filters (multicast, vlan, receive) */
drivers/net/ethernet/intel/e1000/e1000_hw.h:514: * Registers) holds the directed and multicast addresses that we monitor. We
drivers/net/ethernet/intel/e1000/e1000_hw.h:516: * E1000_RAR_ENTRIES - 1 multicast addresses.
drivers/net/ethernet/intel/e1000/e1000_hw.h:1841:#define E1000_RCTL_MPE            0x00000010	/* multicast promiscuous enab */
drivers/net/ethernet/intel/e1000/e1000_hw.h:1852:#define E1000_RCTL_MO_SHIFT       12	/* multicast offset shift */
drivers/net/ethernet/intel/e1000/e1000_hw.h:1853:#define E1000_RCTL_MO_0           0x00000000	/* multicast offset 11:0 */
drivers/net/ethernet/intel/e1000/e1000_hw.h:1854:#define E1000_RCTL_MO_1           0x00001000	/* multicast offset 12:1 */
drivers/net/ethernet/intel/e1000/e1000_hw.h:1855:#define E1000_RCTL_MO_2           0x00002000	/* multicast offset 13:2 */
drivers/net/ethernet/intel/e1000/e1000_hw.h:1856:#define E1000_RCTL_MO_3           0x00003000	/* multicast offset 15:4 */
drivers/net/ethernet/intel/e1000/e1000_hw.h:1857:#define E1000_RCTL_MDR            0x00004000	/* multicast desc ring 0 */
drivers/net/ethernet/intel/ixgb/ixgb_main.c:1081: * The set_multi entry point is called whenever the multicast address
drivers/net/ethernet/intel/ixgb/ixgb_main.c:1083: * responsible for configuring the hardware for proper multicast,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:1672:		/* fix up multicast stats by removing broadcasts */
drivers/net/ethernet/intel/ixgb/ixgb_main.c:1749:	netdev->stats.multicast = adapter->stats.mprcl;
drivers/net/ethernet/intel/ixgb/ixgb_ethtool.c:62:	{"multicast", IXGB_NETDEV_STAT(stats.multicast)},
drivers/net/ethernet/intel/ixgb/ixgb_hw.h:770:/* Filters (multicast, vlan, receive) */
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:289: * Initializes the multicast table.
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:380: * of the receive address registers. Clears the multicast table. Assumes
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:421: * Updates the MAC's list of multicast addresses.
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:424: * mc_addr_list - the list of new multicast addresses
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:429: * address registers and the multicast table. Uses receive address registers
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:430: * for the first 15 multicast addresses, and hashes the rest into the
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:431: * multicast table.
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:464:		pr_debug("Adding the multicast addresses:\n");
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:467:		/* Place this multicast address in the RAR if there is room, *
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:472:			pr_debug("Added a multicast address to RAR[%d]\n", i);
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:489: * Hashes an address to determine its location in the multicast table
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:492: * mc_addr - the multicast address to hash
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:540: * Sets the bit in the multicast table corresponding to the hash value.
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:1130:	/* Make sure it is not a multicast address */
drivers/net/ethernet/intel/ixgb/ixgb_hw.c:1132:		pr_debug("MAC address is multicast\n");
drivers/net/ethernet/intel/i40e/i40e_ethtool.c:59:	I40E_NETDEV_STAT(multicast),
drivers/net/ethernet/intel/i40e/i40e_debugfs.c:413:		 "    net_stats: multicast = %lu, collisions = %lu\n",
drivers/net/ethernet/intel/i40e/i40e_debugfs.c:414:		 (long unsigned int)nstat->multicast,
drivers/net/ethernet/intel/i40e/i40e_debugfs.c:452:		 "    net_stats_offsets: multicast = %lu, collisions = %lu\n",
drivers/net/ethernet/intel/i40e/i40e_debugfs.c:453:		 (long unsigned int)vsi->net_stats_offsets.multicast,
drivers/net/ethernet/intel/i40e/i40e_virtchnl.h:255: * VF sends this message in order to add one or more unicast or multicast
drivers/net/ethernet/intel/i40e/i40e_virtchnl.h:261: * VF sends this message in order to remove one or more unicast or multicast
drivers/net/ethernet/intel/i40e/i40e_common.c:713: * @set: set multicast promiscuous enable/disable
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:1088:/* Add multicast E-Tag (direct 0x0257)
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:1089: * del multicast E-Tag (direct 0x0258) only uses pv_seid and etag fields
drivers/net/ethernet/intel/i40e/i40e_main.c:399:	stats->multicast	= vsi_stats->multicast;
drivers/net/ethernet/intel/i40e/i40e_main.c:810:	ons->multicast = oes->rx_multicast;
drivers/net/ethernet/intel/i40e/i40e_main.c:811:	ns->multicast = es->rx_multicast;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:1901:	"tx_errors", "rx_dropped", "tx_dropped", "multicast", "collisions",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:2474:		/* Firmware cannot support multicast without STATS_DMA_V2 */
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:3165:	/* This firmware is known to not support multicast */
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:3169:	/* Disable multicast filtering */
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:3179:		/* request to disable multicast filtering, so quit here */
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:3193:	/* Walk the multicast list, and add each address */
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:3207:	/* Enable multicast filtering */
drivers/net/ethernet/myricom/myri10ge/myri10ge_mcp.h:200:	 * data0,MSH(data1) = multicast group address */
drivers/net/ethernet/myricom/myri10ge/myri10ge_mcp.h:205:	 * data0,MSH(data1) = multicast group address */
drivers/net/ethernet/ibm/ehea/ehea_main.c:352:	stats->multicast = port->stats.multicast;
drivers/net/ethernet/ibm/ehea/ehea_main.c:383:	stats->multicast = cb2->rxmcp;
drivers/net/ethernet/ibm/ehea/ehea_main.c:1964:			/* Dropping the current multicast list failed.
drivers/net/ethernet/ibm/ehea/ehea.h:400:	u64 max_mc_mac;            /* max number of multicast mac addresses */
drivers/net/ethernet/ibm/emac/core.c:979:	DBG(dev, "multicast" NL);
drivers/net/ethernet/ibm/ibmveth.c:922:	 * multicast destinations within the system.
drivers/net/ethernet/ibm/ibmveth.c:1205:			/* add the multicast address to the filter table */
drivers/net/ethernet/sgi/meth.c:61: * Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
drivers/net/ethernet/sgi/ioc3-eth.c:1530: * Given a multicast ethernet address, this routine calculates the
drivers/net/ethernet/sgi/ioc3-eth.c:1651:			   multicast packets anyway,  so skip computing all the
drivers/net/ethernet/sgi/meth.h:96:		u64		multicast:1;
drivers/net/ethernet/sgi/meth.h:128:#define METH_ACCEPT_MCAST 0x20	/* 01: Accept physical, broadcast, and multicast filter matches only */
drivers/net/ethernet/sgi/meth.h:129:#define METH_ACCEPT_AMCAST 0x40	/* 10: Accept physical, broadcast, and all multicast packets */
drivers/net/ethernet/packetengines/hamachi.c:1756:	dev->stats.multicast = readl(ioaddr + 0x320);
drivers/net/ethernet/packetengines/yellowfin.c:1279:/* Set or clear the multicast filter for this adaptor. */
drivers/net/ethernet/packetengines/yellowfin.c:1295:	} else if (!netdev_mc_empty(dev)) { /* Must use the multicast hash table. */
drivers/net/ethernet/freescale/fec_main.c.orig:1067:	/* Setup multicast filter. */
drivers/net/ethernet/freescale/fec_main.c.orig:2914:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/freescale/fec_main.c.orig:2918: * a group multicast address, and discard those that are not.  I guess I
drivers/net/ethernet/freescale/fec_main.c.orig:2946:		/* Catch all multicast addresses, so set the
drivers/net/ethernet/freescale/ucc_geth.c:2025:			/* Catch all multicast addresses, so set the
drivers/net/ethernet/freescale/fec_main.c:1067:	/* Setup multicast filter. */
drivers/net/ethernet/freescale/fec_main.c:2924:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/freescale/fec_main.c:2928: * a group multicast address, and discard those that are not.  I guess I
drivers/net/ethernet/freescale/fec_main.c:2956:		/* Catch all multicast addresses, so set the
drivers/net/ethernet/freescale/fec.h:87:#define RMON_T_MC_PKT		0x20C /* RMON TX multicast pkts */
drivers/net/ethernet/freescale/fec.h:116:#define RMON_R_MC_PKT		0x28C /* RMON RX multicast pkts */
drivers/net/ethernet/freescale/fs_enet/fec.h:4:/* CRC polynomium used by the FEC for the multicast group filtering */
drivers/net/ethernet/freescale/fs_enet/mac-fcc.c:402:	/* Restore multicast and promiscuous settings */
drivers/net/ethernet/freescale/fs_enet/mac-fec.c:275:	 * Reset all multicast.
drivers/net/ethernet/freescale/fs_enet/fs_enet.h:163:			u32 hthi, htlo;		/* state for multicast */
drivers/net/ethernet/freescale/fs_enet/fs_enet.h:179:			u32 hthi, htlo;		/* state for multicast */
drivers/net/ethernet/freescale/gianfar_ethtool.c:91:	"receive-multicast-packet",
drivers/net/ethernet/freescale/gianfar_ethtool.c:107:	"tx-multicast-packets",
drivers/net/ethernet/freescale/gianfar.c:3189:/* Update the hash table based on the current list of multicast
drivers/net/ethernet/freescale/gianfar.c:3214:		/* Set the hash to rx all multicast frames */
drivers/net/ethernet/freescale/gianfar.c:3295: * 1) Take the Destination Address (ie the multicast address), and
drivers/net/ethernet/freescale/fec_main_BACKUP.c:1067:	/* Setup multicast filter. */
drivers/net/ethernet/freescale/fec_main_BACKUP.c:2913:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/freescale/fec_main_BACKUP.c:2917: * a group multicast address, and discard those that are not.  I guess I
drivers/net/ethernet/freescale/fec_main_BACKUP.c:2945:		/* Catch all multicast addresses, so set the
drivers/net/ethernet/freescale/ucc_geth_ethtool.c:49:	"tx-multicast-frames",
drivers/net/ethernet/freescale/ucc_geth_ethtool.c:54:	"rx-multicast-frames",
drivers/net/ethernet/freescale/fec_main.c~:1067:	/* Setup multicast filter. */
drivers/net/ethernet/freescale/fec_main.c~:2913:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/freescale/fec_main.c~:2917: * a group multicast address, and discard those that are not.  I guess I
drivers/net/ethernet/freescale/fec_main.c~:2945:		/* Catch all multicast addresses, so set the
drivers/net/ethernet/freescale/fec_mpc52xx.c:503:	stats->multicast = in_be32(&fec->rmon_r_mc_pkt);
drivers/net/ethernet/freescale/fec_mpc52xx.c:546: * Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/amd/pcnet32.c:2584:	/* set all multicast bits */
drivers/net/ethernet/amd/pcnet32.c:2594:	/* clear the multicast filter */
drivers/net/ethernet/amd/pcnet32.c:2610: * Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/amd/7990.c:221:	/* Clear the multicast filter */
drivers/net/ethernet/amd/7990.c:603:	/* set all multicast bits */
drivers/net/ethernet/amd/7990.c:609:	/* clear the multicast filter */
drivers/net/ethernet/amd/am79c961a.c:378: * Set or clear promiscuous/multicast mode filter for this adapter.
drivers/net/ethernet/amd/am79c961a.c:408:	 * Update the multicast hash table
drivers/net/ethernet/amd/atarilance.c:39:		  This might be the reason why multicast-mode didn't work
drivers/net/ethernet/amd/atarilance.c:1068:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/amd/atarilance.c:1070:   num_addrs == 0		Normal mode, clear multicast list
drivers/net/ethernet/amd/atarilance.c:1095:		/* We don't use the multicast table, but rely on upper-layer
drivers/net/ethernet/amd/au1000_eth.c:684:		ps->multicast++;
drivers/net/ethernet/amd/au1000_eth.c:974:		netdev_info(dev, "Pass all multicast\n");
drivers/net/ethernet/amd/nmclan_cs.c:66:   kernel with multicast ip enabled.
drivers/net/ethernet/amd/nmclan_cs.c:752:  /* Restore the multicast list and enable TX and RX. */
drivers/net/ethernet/amd/nmclan_cs.c:1144:  pr_debug(" multicast=%-7ld         collisions=%ld\n",
drivers/net/ethernet/amd/nmclan_cs.c:1145:	(long)pstats->multicast, (long)pstats->collisions);
drivers/net/ethernet/amd/nmclan_cs.c:1238:  /* lp->linux_stats.multicast; */
drivers/net/ethernet/amd/nmclan_cs.c:1353:	Restores the multicast filter for MACE chip to the last
drivers/net/ethernet/amd/nmclan_cs.c:1373:    pr_debug("Attempt to restore multicast list detected.\n");
drivers/net/ethernet/amd/nmclan_cs.c:1405:	Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/amd/nmclan_cs.c:1409:	num_addrs == 0	Normal mode, clear multicast list
drivers/net/ethernet/amd/nmclan_cs.c:1439:    /* Calculate multicast logical address filter */
drivers/net/ethernet/amd/declance.c:210:	unsigned short filter[4];	/* multicast filter */
drivers/net/ethernet/amd/declance.c:789:	/* Set mode and clear multicast filter only at device open,
drivers/net/ethernet/amd/declance.c:791:	 * forget multicast filters.
drivers/net/ethernet/amd/declance.c:948:	/* set all multicast bits */
drivers/net/ethernet/amd/declance.c:956:	/* clear the multicast filter */
drivers/net/ethernet/amd/declance.c:1246:	 * multicast list update event, because such events
drivers/net/ethernet/amd/a2065.c:216:	/* Clear the multicast filter */
drivers/net/ethernet/amd/a2065.c:592:	/* set all multicast bits */
drivers/net/ethernet/amd/a2065.c:598:	/* clear the multicast filter */
drivers/net/ethernet/amd/amd8111e.c:943:	/* stats.multicast*/
drivers/net/ethernet/amd/amd8111e.c:944:	new_stats->multicast = amd8111e_read_mib(mmio, rcv_multicast_pkts);
drivers/net/ethernet/amd/amd8111e.c:1362:This function sets promiscuos mode, all-multi mode or the multicast address
drivers/net/ethernet/amd/amd8111e.c:1380:		/* get all multicast packet */
drivers/net/ethernet/amd/amd8111e.c:1395:	/* load all the multicast addresses in the logic filter */
drivers/net/ethernet/amd/ariadne.c:637:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/amd/ariadne.c:639: * num_addrs == 0	Normal mode, clear multicast list
drivers/net/ethernet/amd/ariadne.c:664:		/* We don't use the multicast table,
drivers/net/ethernet/amd/sun3lance.c:889:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/amd/sun3lance.c:891:   num_addrs == 0		Normal mode, clear multicast list
drivers/net/ethernet/amd/sun3lance.c:916:		/* We don't use the multicast table, but rely on upper-layer
drivers/net/ethernet/amd/sunlance.c:36: *		  Stole multicast code from depca.c, fixed lance_tx.
drivers/net/ethernet/amd/sunlance.c:39: *	 8/21/96: Fixed the multicast code (Pedro Roque)
drivers/net/ethernet/amd/sunlance.c:933:	/* Set mode and clear multicast filter only at device open,
drivers/net/ethernet/amd/sunlance.c:935:	 * forget multicast filters.
drivers/net/ethernet/amd/sunlance.c:1170:	/* set all multicast bits */
drivers/net/ethernet/amd/sunlance.c:1459:	 * multicast list update event, because such events
drivers/net/ethernet/amd/lance.c:1280:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/amd/lance.c:1299:		/* FIXIT: We don't use the multicast table, but rely on upper-layer filtering. */
drivers/net/ethernet/amd/amd8111e.h:581:#define MAX_FILTER_SIZE			64 /* Maximum multicast address */
drivers/net/ethernet/amd/ni65.c:55: * 95.Nov.18: multicast tweaked (AC).
drivers/net/ethernet/i825xx/lib82596.c:1331: *    Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/i825xx/lib82596.c:1342:		   "%s: set multicast list, %d entries, promisc %s, allmulti %s\n",
drivers/net/ethernet/i825xx/lib82596.c:1382:		printk(KERN_NOTICE "%s: Only %d multicast addresses supported",
drivers/net/ethernet/i825xx/sun3_82586.c:548:			printk("%s: Can't apply multicast-address-list.\n",dev->name);
drivers/net/ethernet/i825xx/82596.c:1449: *    Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/i825xx/82596.c:1457:	DEB(DEB_MULTI,printk(KERN_DEBUG "%s: set multicast list, %d entries, promisc %s, allmulti %s\n",
drivers/net/ethernet/i825xx/82596.c:1490:		printk(KERN_ERR "%s: Only %d multicast addresses supported",
drivers/net/ethernet/i825xx/82596.c:1499:		if (wait_cfg(dev, &lp->mc_cmd.cmd, 1000, "multicast list change request timed out"))
drivers/net/ethernet/i825xx/ether1.h:120:typedef struct { /* set multicast */
drivers/net/ethernet/i825xx/ether1.c:567:		printk (KERN_WARNING "%s: can't initialise 82586: set multicast status %04X\n", dev->name, status);
drivers/net/ethernet/i825xx/ether1.c:956: * Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/i825xx/ether1.c:958: * num_addrs == 0	Normal mode, clear multicast list.
drivers/net/ethernet/seeq/ether3.c:19: *				multicast mode.  Receiver routine optimised.
drivers/net/ethernet/seeq/ether3.c:435: * Set or clear promiscuous/multicast mode filter for this adaptor.
drivers/net/ethernet/xircom/xirc2ps_cs.c:145:    PhyPkt = 0x01,	/* set:physical packet, clear: multicast packet */
drivers/net/ethernet/xircom/xirc2ps_cs.c:1102:		    dev->stats.multicast++;
drivers/net/ethernet/xircom/xirc2ps_cs.c:1297: * the next 9 addresses are taken from the multicast list and
drivers/net/ethernet/xircom/xirc2ps_cs.c:1330: * Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/xircom/xirc2ps_cs.c:1332: * multicast promiscuous mode.
drivers/net/ethernet/neterion/s2io-regs.h:723:#define S2IO_XENA_MAX_MC_ADDRESSES	64	/* multicast addresses */
drivers/net/ethernet/neterion/s2io.c:4896:	/* The adapter MAC interprets pause frames as multicast packets, but
drivers/net/ethernet/neterion/s2io.c:4897:	 * does not pass them up.  This erroneously increases the multicast
drivers/net/ethernet/neterion/s2io.c:4898:	 * packet count and needs to be deducted when the multicast frame count
drivers/net/ethernet/neterion/s2io.c:4904:	delta -= sp->stats.multicast;
drivers/net/ethernet/neterion/s2io.c:4905:	sp->stats.multicast += delta;
drivers/net/ethernet/neterion/s2io.c:4906:	dev->stats.multicast += delta;
drivers/net/ethernet/neterion/s2io.c:4922: *  s2io_set_multicast - entry point for multicast address enable/disable.
drivers/net/ethernet/neterion/s2io.c:4926: *  whenever multicast addresses must be enabled/disabled. This also gets
drivers/net/ethernet/neterion/s2io.c:4928: *  determine, if multicast address must be enabled or if promiscuous mode
drivers/net/ethernet/neterion/s2io.c:5097:/* read from CAM unicast & multicast addresses and store it in
drivers/net/ethernet/neterion/s2io.c:5106:	/* store unicast & multicast mac addresses */
drivers/net/ethernet/neterion/s2io.c:5116:/* restore unicast & multicast MAC to CAM from def_mac_addr structure */
drivers/net/ethernet/neterion/s2io.c:5126:	/* restore multicast mac address */
drivers/net/ethernet/neterion/s2io.c:5132:/* add a multicast MAC address to CAM */
drivers/net/ethernet/neterion/s2io.c:5146:	/* check if the multicast mac already preset in CAM */
drivers/net/ethernet/neterion/s2io.c:5158:			  "CAM full no space left for multicast MAC\n");
drivers/net/ethernet/neterion/s2io.c:5189:/* deletes a specified unicast/multicast mac entry from CAM */
drivers/net/ethernet/neterion/s2io.c:8014:	/* initialize number of multicast & unicast MAC entries variables */
drivers/net/ethernet/neterion/vxge/vxge-main.c:1110: * Entry point for multicast address enable/disable
drivers/net/ethernet/neterion/vxge/vxge-main.c:1112: * whenever multicast addresses must be enabled/disabled. This also gets
drivers/net/ethernet/neterion/vxge/vxge-main.c:1114: * determine, if multicast address must be enabled or if promiscuous mode
drivers/net/ethernet/neterion/vxge/vxge-main.c:1148:						"multicast, status %d", status);
drivers/net/ethernet/neterion/vxge/vxge-main.c:1158:						"multicast, status %d", status);
drivers/net/ethernet/neterion/vxge/vxge-main.c:1224:						"multicast address failed",
drivers/net/ethernet/neterion/vxge/vxge-main.c:1253:		/* Enable all multicast */
drivers/net/ethernet/neterion/vxge/vxge-main.c:1545:	/* Enable all multicast */
drivers/net/ethernet/neterion/vxge/vxge-main.c:1550:				"%s:%d Enabling multicast failed",
drivers/net/ethernet/neterion/vxge/vxge-main.c:2799:	/* Restore the DA, VID table and also multicast and promiscuous mode
drivers/net/ethernet/neterion/vxge/vxge-main.c:2811:					"%s:%d Enabling multicast failed",
drivers/net/ethernet/neterion/vxge/vxge-main.c:2816:	/* Enable vpath to sniff all unicast/multicast traffic that not
drivers/net/ethernet/neterion/vxge/vxge-main.c:3131:		u64 packets, bytes, multicast;
drivers/net/ethernet/neterion/vxge/vxge-main.c:3137:			multicast = rxstats->rx_mcast;
drivers/net/ethernet/neterion/vxge/vxge-main.c:3143:		net_stats->multicast += multicast;
drivers/net/ethernet/neterion/vxge/vxge-traffic.c:2117: * vxge_hw_vpath_mcast_enable - Enable multicast addresses.
drivers/net/ethernet/neterion/vxge/vxge-traffic.c:2120: * Enable Titan-e multicast addresses.
drivers/net/ethernet/neterion/vxge/vxge-traffic.c:2149: * vxge_hw_vpath_mcast_disable - Disable  multicast addresses.
drivers/net/ethernet/neterion/vxge/vxge-traffic.c:2152: * Disable Titan-e multicast addresses.
drivers/net/ethernet/neterion/vxge/vxge-traffic.h:520: *            a non-unicast (broadcast or multicast) address. Only includes
drivers/net/ethernet/neterion/vxge/vxge-traffic.h:943: *            a non-unicast (broadcast or multicast) address. Only includes
drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c:113:		/* Hash filter for multicast */
drivers/net/ethernet/stmicro/stmmac/stmmac_main.c:2239: *  stmmac_set_rx_mode - entry point for multicast addressing
drivers/net/ethernet/stmicro/stmmac/stmmac_main.c:2243: *  whenever multicast addresses must be enabled/disabled.
drivers/net/ethernet/stmicro/stmmac/norm_desc.c:70: * and, if required, updates the multicast statistics.
drivers/net/ethernet/stmicro/stmmac/dwmac1000.h:163:#define GMAC_FRAME_FILTER_PM	0x00000010	/* Pass all multicast */
drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c:107:	} else if (netdev_mc_empty(dev)) {	/* no multicast */
drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c:115:		 * filter for multicast
drivers/net/ethernet/mellanox/mlx4/resource_tracker.c:3604:	/* make sure it isn't multicast or broadcast mac*/
drivers/net/ethernet/mellanox/mlx4/cmd.c:1299:	/* Native multicast commands are not available for guests */
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:926:			/* Add the default qp number as multicast
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:934:					en_err(priv, "Failed enabling multicast promiscuous mode\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:949:		/* Disable port multicast filter (unconditionally) */
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:953:			en_err(priv, "Failed disabling multicast filter\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:994:				en_err(priv, "Failed disabling multicast promiscuous mode\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1023:	/* Enable/disable the multicast filter according to IFF_ALLMULTI */
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1028:			en_err(priv, "Failed disabling multicast filter\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1030:		/* Add the default qp number as multicast promisc */
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1050:				en_err(priv, "Failed entering multicast promisc mode\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1073:				en_err(priv, "Failed disabling multicast promiscuous mode\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1080:			en_err(priv, "Failed disabling multicast filter\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1086:		/* Update multicast list - we cache all addresses so they won't
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1099:			en_err(priv, "Failed enabling multicast filter\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1113:					en_err(priv, "Fail to detach multicast address\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1118:						en_err(priv, "Failed to detach multicast address\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1136:					en_err(priv, "Fail to attach multicast address\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1141:					en_err(priv, "Failed to attach multicast address\n");
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1703:	/* Schedule multicast task to populate multicast list */
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:1808:	/* Flush multicast filter */
drivers/net/ethernet/mellanox/mlx4/en_port.h:189:	/* Received multicast frames with good CRC */
drivers/net/ethernet/mellanox/mlx4/en_port.h:428:	/* Transmit multicast frames with a good CRC */
drivers/net/ethernet/mellanox/mlx4/en_port.h:439:	/* Transmit good frames that are neither broadcast nor multicast */
drivers/net/ethernet/mellanox/mlx4/en_main.c:291:	/* Create our own workqueue for reset/multicast tasks
drivers/net/ethernet/mellanox/mlx4/main.c:1227:	 * required, but for simplicity just map the whole multicast
drivers/net/ethernet/mellanox/mlx4/main.c:1833:			mlx4_err(dev, "Failed to initialize multicast group table, aborting.\n");
drivers/net/ethernet/mellanox/mlx4/fw.c:87:		[ 4] = "reliable multicast",
drivers/net/ethernet/mellanox/mlx4/fw.c:99:		[19] = "Raw multicast support",
drivers/net/ethernet/mellanox/mlx4/fw.c:101:		[21] = "UD multicast support",
drivers/net/ethernet/mellanox/mlx4/en_ethtool.c:103:	"tx_errors", "rx_dropped", "tx_dropped", "multicast", "collisions",
drivers/net/ethernet/mellanox/mlx4/en_port.c:163:	stats->multicast = be64_to_cpu(mlx4_en_stats->MCAST_prio_0) +
drivers/net/ethernet/icplus/ipg.c:569:/* Determine and configure multicast operation and set
drivers/net/ethernet/icplus/ipg.c:590:		/* NIC to be configured to receive all multicast
drivers/net/ethernet/icplus/ipg.c:595:		 * multicast addresses. */
drivers/net/ethernet/icplus/ipg.c:602:	 * address all incoming multicast frames whose destination
drivers/net/ethernet/icplus/ipg.c:603:	 * address has the multicast bit set. The least significant
drivers/net/ethernet/icplus/ipg.c:613:	/* Cycle through all multicast addresses to filter. */
drivers/net/ethernet/icplus/ipg.c:615:		/* Calculate CRC result for each multicast address. */
drivers/net/ethernet/icplus/ipg.c:1024:	sp->stats.multicast += ipg_r32(IPG_MCSTOCTETRCVDOK);
drivers/net/ethernet/micrel/ks8842.c:549:		netdev->stats.multicast++;
drivers/net/ethernet/micrel/ks8695net.c:317:/* Maximum number of multicast addresses which the KS8695 HW supports */
drivers/net/ethernet/micrel/ks8695net.c:323: *	@addr: The multicast address list to use
drivers/net/ethernet/micrel/ks8695net.c:1081: *	ks8695_set_multicast - Set up the multicast behaviour of the interface
drivers/net/ethernet/micrel/ks8695net.c:1085: *	and multicast reception behaviour for the interface.
drivers/net/ethernet/micrel/ks8695net.c:1104:		/* enable all multicast mode */
drivers/net/ethernet/micrel/ks8695net.c:1107:		/* more specific multicast addresses than can be
drivers/net/ethernet/micrel/ks8851_mll.c:407: * @mcast_lst_size   	: size of multicast list.
drivers/net/ethernet/micrel/ks8851_mll.c:408: * @mcast_lst    	: multicast list.
drivers/net/ethernet/micrel/ks8851_mll.c:409: * @mcast_bits    	: multicast enabed.
drivers/net/ethernet/micrel/ks8851_mll.c:1100:* ks_set_grpaddr - set multicast information
drivers/net/ethernet/micrel/ks8851_mll.c:1128:* ks_clear_mcast - clear multicast information
drivers/net/ethernet/micrel/ks8851.c:39: * such as the multicast hash-filter and the receive register settings. This
drivers/net/ethernet/micrel/ks8851.c:73: * @rxctrl_work: Work queue for updating RX mode and multicast lists
drivers/net/ethernet/micrel/ks8851.c:658:		/* update the multicast hash table */
drivers/net/ethernet/micrel/ks8851.c:987:		/* accept all multicast packets */
drivers/net/ethernet/micrel/ks8851.c:995:		/* accept some multicast */
drivers/net/ethernet/micrel/ksz884x.c:847:	u32 multicast:1;
drivers/net/ethernet/micrel/ksz884x.c:865:	u32 multicast:1;
drivers/net/ethernet/micrel/ksz884x.c:1259: * @all_multi:		Counter to keep track of all multicast mode set.
drivers/net/ethernet/micrel/ksz884x.c:1261: * @multi_bits:		Cached multicast hash table settings.
drivers/net/ethernet/micrel/ksz884x.c:1465: * @multicast:		The all multicast state of the device.
drivers/net/ethernet/micrel/ksz884x.c:1481:	int multicast;
drivers/net/ethernet/micrel/ksz884x.c:3660: * hw_add_wol_mcast - add multicast pattern
drivers/net/ethernet/micrel/ksz884x.c:3663: * This routine is used to add multicast pattern for waking up the host.
drivers/net/ethernet/micrel/ksz884x.c:3665: * It is assumed the multicast packet is the ICMPv6 neighbor solicitation used
drivers/net/ethernet/micrel/ksz884x.c:3666: * by IPv6 ping command.  Note that multicast packets are filtred through the
drivers/net/ethernet/micrel/ksz884x.c:3667: * multicast hash table, so not all multicast packets can wake up the host.
drivers/net/ethernet/micrel/ksz884x.c:4163: * hw_clr_multicast - clear multicast addresses
drivers/net/ethernet/micrel/ksz884x.c:4166: * This routine removes all multicast addresses set in the hardware.
drivers/net/ethernet/micrel/ksz884x.c:4180: * hw_set_grp_addr - set multicast addresses
drivers/net/ethernet/micrel/ksz884x.c:4183: * This routine programs multicast addresses for the hardware to accept those
drivers/net/ethernet/micrel/ksz884x.c:4208: * hw_set_multicast - enable or disable all multicast receiving
drivers/net/ethernet/micrel/ksz884x.c:4210: * @multicast:	To turn on or off the all multicast feature.
drivers/net/ethernet/micrel/ksz884x.c:4212: * This routine enables/disables the hardware to accept all multicast packets.
drivers/net/ethernet/micrel/ksz884x.c:4214:static void hw_set_multicast(struct ksz_hw *hw, u8 multicast)
drivers/net/ethernet/micrel/ksz884x.c:4219:	if (multicast)
drivers/net/ethernet/micrel/ksz884x.c:5399:	if (priv->multicast)
drivers/net/ethernet/micrel/ksz884x.c:5518:	priv->multicast = 0;
drivers/net/ethernet/micrel/ksz884x.c:5626:	dev->stats.multicast = 0;
drivers/net/ethernet/micrel/ksz884x.c:5636:		dev->stats.multicast += (unsigned long)
drivers/net/ethernet/micrel/ksz884x.c:5733:	int multicast)
drivers/net/ethernet/micrel/ksz884x.c:5735:	if (multicast != priv->multicast) {
drivers/net/ethernet/micrel/ksz884x.c:5738:		if (multicast)
drivers/net/ethernet/micrel/ksz884x.c:5742:		priv->multicast = multicast;
drivers/net/ethernet/micrel/ksz884x.c:5744:		/* Turn on/off all multicast mode. */
drivers/net/ethernet/micrel/ksz884x.c:5754: * This routine is used to set multicast addresses or put the network device
drivers/net/ethernet/micrel/ksz884x.c:5763:	int multicast = (dev->flags & IFF_ALLMULTI);
drivers/net/ethernet/micrel/ksz884x.c:5768:		multicast |= (dev->flags & IFF_MULTICAST);
drivers/net/ethernet/micrel/ksz884x.c:5769:	dev_set_multicast(priv, hw, multicast);
drivers/net/ethernet/micrel/ksz884x.c:5778:		/* List too big to support so turn on all multicast mode. */
drivers/net/ethernet/micrel/ksz884x.c:6753: * multicast hash tables.
drivers/net/ethernet/micrel/ksz884x.c:6759: * Protocol, this enables a feature in which most unicast and multicast packets
drivers/net/ethernet/adi/bfin_mac.c:1470: * either make it accept multicast packets, go into
drivers/net/ethernet/adi/bfin_mac.c:1472: * a select set of multicast packets
drivers/net/ethernet/adi/bfin_mac.c:1484:		/* accept all multicast */
drivers/net/ethernet/adi/bfin_mac.c:1489:		/* set up multicast hash table */
drivers/net/ethernet/adi/bfin_mac.c:1495:		/* clear promisc or multicast mode */
drivers/net/ethernet/smsc/epic100.c:1356:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/smsc/epic100.c:1373:		/* There is apparently a chip bug, so the multicast filter
drivers/net/ethernet/smsc/smsc9420.c:791:		dev->stats.multicast++;
drivers/net/ethernet/smsc/smsc911x.c:1188:			dev->stats.multicast++;
drivers/net/ethernet/smsc/smsc911x.c:1298:	/* Performs the multicast & mac_cr update.  This is called when
drivers/net/ethernet/smsc/smsc911x.c:1759:		/* Enabling all multicast mode */
drivers/net/ethernet/smsc/smsc911x.c:1765:		/* Enabling specific multicast addresses */
drivers/net/ethernet/smsc/smsc911x.c:1841:		/* Called when there is a multicast update scheduled and
drivers/net/ethernet/smsc/smc91x.h:557:#define ES_LTX_MULT	0x0008	// Last tx was a multicast
drivers/net/ethernet/smsc/smc91x.h:575:#define RCR_ALMUL	0x0004	// When set accepts all multicast frames
drivers/net/ethernet/smsc/smc91c92_cs.c:230:#define  RCR_ALMUL	0x4 	/* receive all multicast packets */
drivers/net/ethernet/smsc/smc91c92_cs.c:1520:	    dev->stats.multicast++;
drivers/net/ethernet/smsc/smc91c92_cs.c:1539:    promiscuous/multicast mode changes, and by the open/reset code to
drivers/net/ethernet/smsc/smc91c92_cs.c:1540:    initialize the Rx registers.  We always set the multicast list and
drivers/net/ethernet/smsc/smc9194.h:84:#define RCR_ALMUL	0x4 	/* receive all multicast packets */
drivers/net/ethernet/smsc/smc9194.c:24: . Hardware multicast code from Peter Cammaert ( pc@denkart.be )
drivers/net/ethernet/smsc/smc9194.c:35: .	01/29/96  Erik Stahlman	 fixed autoirq, added multicast
drivers/net/ethernet/smsc/smc9194.c:49: .	03/06/96  Erik Stahlman  Added hardware multicast from Peter Cammaert
drivers/net/ethernet/smsc/smc9194.c:230: . programs ) and multicast modes.
drivers/net/ethernet/smsc/smc9194.c:406: .    This sets the internal hardware table to filter out unwanted multicast
drivers/net/ethernet/smsc/smc9194.c:411: .    multicast packet is accepted.  Otherwise, it's dropped silently.
drivers/net/ethernet/smsc/smc9194.c:1196:		/* set multicast stats */
drivers/net/ethernet/smsc/smc9194.c:1198:			dev->stats.multicast++;
drivers/net/ethernet/smsc/smc9194.c:1475: . either make it accept multicast packets, go into
drivers/net/ethernet/smsc/smc9194.c:1477: . a select set of multicast packets
drivers/net/ethernet/smsc/smc9194.c:1492:	/* Here, I am setting this to accept all multicast packets.
drivers/net/ethernet/smsc/smc9194.c:1493:	   I don't need to zero the multicast table, because the flag is
drivers/net/ethernet/smsc/smc9194.c:1499:	/* We just get all multicast packets even if we only want them
drivers/net/ethernet/smsc/smc9194.c:1517:		  since I'm disabling all multicast entirely, I need to
drivers/net/ethernet/smsc/smc9194.c:1518:		  clear the multicast list
drivers/net/ethernet/smsc/smc91x.c:32: * hardware multicast code:
drivers/net/ethernet/smsc/smc91x.c:454:		/* set multicast stats */
drivers/net/ethernet/smsc/smc91x.c:456:			dev->stats.multicast++;
drivers/net/ethernet/smsc/smc91x.c:1366: * either make it accept multicast packets, go into
drivers/net/ethernet/smsc/smc91x.c:1368: * a select set of multicast packets
drivers/net/ethernet/smsc/smc91x.c:1390:	 * Here, I am setting this to accept all multicast packets.
drivers/net/ethernet/smsc/smc91x.c:1391:	 * I don't need to zero the multicast table, because the flag is
drivers/net/ethernet/smsc/smc91x.c:1401:	 * multicast packets before they take up memory.
drivers/net/ethernet/smsc/smc91x.c:1405:	 * multicast packet is accepted.  Otherwise, it's dropped silently.
drivers/net/ethernet/smsc/smc91x.c:1441:		 * since I'm disabling all multicast entirely, I need to
drivers/net/ethernet/smsc/smc91x.c:1442:		 * clear the multicast list
drivers/net/ethernet/smsc/smc911x.c:398:				dev->stats.multicast++;
drivers/net/ethernet/smsc/smc911x.c:1294: * either make it accept multicast packets, go into
drivers/net/ethernet/smsc/smc911x.c:1296: * a select set of multicast packets
drivers/net/ethernet/smsc/smc911x.c:1317:	 * Here, I am setting this to accept all multicast packets.
drivers/net/ethernet/smsc/smc911x.c:1318:	 * I don't need to zero the multicast table, because the flag is
drivers/net/ethernet/smsc/smc911x.c:1328:	 * multicast packets before they take up memory.
drivers/net/ethernet/smsc/smc911x.c:1332:	 * multicast packet is accepted.  Otherwise, it's dropped silently.
drivers/net/ethernet/smsc/smc911x.c:1366:		 * since I'm disabling all multicast entirely, I need to
drivers/net/ethernet/smsc/smc911x.c:1367:		 * clear the multicast list
drivers/net/ethernet/apple/mace.h:162:#define LOGADDR		0x02	/* access multicast filter */
drivers/net/ethernet/apple/bmac.h:153:#define BHASH3		0x700   /* multicast hash register */
drivers/net/ethernet/apple/bmac.h:154:#define BHASH2		0x710   /* multicast hash register */
drivers/net/ethernet/apple/bmac.h:155:#define BHASH1		0x720   /* multicast hash register */
drivers/net/ethernet/apple/bmac.h:156:#define BHASH0		0x730   /* multicast hash register */
drivers/net/ethernet/apple/mace.c:38:/* Chip rev needs workaround on HW & multicast addr change */
drivers/net/ethernet/apple/mace.c:351:    /* clear the multicast filter */
drivers/net/ethernet/apple/bmac.c:41: * CRC polynomial - used in working out multicast filter bits.
drivers/net/ethernet/apple/bmac.c:45:/* switch to use multicast code lifted from sunhme driver */
drivers/net/ethernet/apple/bmac.c:898: * Sync the adapter with the software copy of the multicast mask
drivers/net/ethernet/apple/bmac.c:966:/* Set or clear the multicast filter for this adaptor.
drivers/net/ethernet/apple/bmac.c:968:    num_addrs == 0	Normal mode, clear multicast list
drivers/net/ethernet/apple/macmace.c:52:/* Chip rev needs workaround on HW & multicast addr change */
drivers/net/ethernet/apple/macmace.c:301:	/* clear the multicast filter */
drivers/net/tun.c:653:	/* Remaining multicast addresses are hashed,
drivers/net/tun.c:694:	/* Inexact match (multicast only) */
drivers/net/dsa/mv88e6123_61_65.c:132:	 * multicast frames to the CPU at the highest priority.
drivers/net/dsa/mv88e6131.c:124:	 * highest, and send all special multicast frames to the CPU
drivers/net/dsa/mv88e6131.c:192:		/* On 6085, unknown multicast forward is controlled
drivers/net/dsa/mv88e6131.c:234:	 * forwarding of unknown multicast addresses.
drivers/net/dsa/mv88e6131.c:238:		 * mirroring, and multicast forward is handled in
drivers/net/team/team.c:670: * Send multicast group rejoins
drivers/net/team/team.c:1793:		stats->multicast	+= rx_multicast;
drivers/net/fddi/defxx.c:97: *		or deleting multicast addresses, enabling or disabling packet
drivers/net/fddi/defxx.c:99: *		the driver supports the "get statistics", "set multicast list", and
drivers/net/fddi/defxx.c:179: *							LLC group promiscuous mode if multicast list
drivers/net/fddi/defxx.c:1400:	/* Clear local unicast/multicast address tables and counts */
drivers/net/fddi/defxx.c:2012:	bp->stats.gen.multicast  = bp->rcv_multicast_frames;
drivers/net/fddi/defxx.c:2147: *   on the adapter and/or update multicast address table.
drivers/net/fddi/defxx.c:2163: *			if number of incoming multicast addresses >
drivers/net/fddi/defxx.c:2166: *				set driver-maintained multicast address count to zero
drivers/net/fddi/defxx.c:2169: *				set driver-maintained multicast address count to incoming count
drivers/net/fddi/defxx.c:2194:	/* Else, update multicast address table */
drivers/net/fddi/defxx.c:2200:		 * Check whether incoming multicast address count exceeds table size
drivers/net/fddi/defxx.c:2203:		 *       supporting perfect filtering of multicast packets
drivers/net/fddi/defxx.c:2206:		 *		 additional multicast addresses, the all multicast
drivers/net/fddi/defxx.c:2210:		 *		 multicast addresses, which leaves 62 entries available.
drivers/net/fddi/defxx.c:2213:		 *		 the driver will enable the all multicast filter.
drivers/net/fddi/defxx.c:2214:		 *		 Should the number of multicast addresses drop below
drivers/net/fddi/defxx.c:2230:		/* Copy addresses to multicast address table, then update adapter CAM */
drivers/net/fddi/defxx.c:2239:			DBG_printk("%s: Could not update multicast address table!\n", dev->name);
drivers/net/fddi/defxx.c:2279: *   multicast addresses.  In this routine we'll update the driver and
drivers/net/fddi/defxx.c:2311:	 *       already filled the CAM with 62 multicast addresses.
drivers/net/fddi/defxx.c:2315:	 *		 the LLC group (multicast) promiscuous mode filter as
drivers/net/fddi/defxx.c:2357: *   with desired unicast and multicast address entries.
drivers/net/fddi/defxx.c:2367: *   unicast and multicast address tables.  Since there are only 62
drivers/net/fddi/defxx.c:2376: *   All addresses being added (unicast and multicast) are in canonical
drivers/net/fddi/defxx.c:2391:	 * Note: Even though both the unicast and multicast address
drivers/net/fddi/defxx.c:2396:	 *		 multicast table entry into each command entry.  This
drivers/net/fddi/defxx.c:2416:	/* Now add multicast addresses to command request buffer, if any */
drivers/net/fddi/skfp/srf.c:395:	smt->smt_dest = SMT_SRF_DA ;		/* DA == SRF multicast */
drivers/net/fddi/skfp/fplustm.c:521:	mac->mac_dest = dbeacon_multi ;		/* multicast */
drivers/net/fddi/skfp/fplustm.c:1057: * multicast functions
drivers/net/fddi/skfp/fplustm.c:1100:		Clear all multicast entries
drivers/net/fddi/skfp/fplustm.c:1127:		Add an entry to the multicast table
drivers/net/fddi/skfp/fplustm.c:1129:Para	addr	pointer to a multicast address
drivers/net/fddi/skfp/fplustm.c:1130:	can	= 0:	the multicast address has the physical format
drivers/net/fddi/skfp/fplustm.c:1131:		= 1:	the multicast address has the canonical format
drivers/net/fddi/skfp/fplustm.c:1138:	entries of the multicast table are cleared.
drivers/net/fddi/skfp/fplustm.c:1139:	In this case the driver has to fill the multicast table again.
drivers/net/fddi/skfp/fplustm.c:1141:	the multicast table it must call mac_update_multicast
drivers/net/fddi/skfp/fplustm.c:1142:	to activate the new multicast addresses!
drivers/net/fddi/skfp/fplustm.c:1196:		Update FORMAC multicast registers
drivers/net/fddi/skfp/fplustm.c:1239:			 * write the multicast address into the CAM
drivers/net/fddi/skfp/skfddi.c:511:	/* Clear local multicast address tables */
drivers/net/fddi/skfp/skfddi.c:807: *   on the adapter and/or update multicast address table.
drivers/net/fddi/skfp/skfddi.c:825: *              if number of multicast addresses <= max. multicast number
drivers/net/fddi/skfp/skfddi.c:860:	/* Else, update multicast address table */
drivers/net/fddi/skfp/skfddi.c:876:				// point to first multicast addr
drivers/net/fddi/skfp/skfddi.c:1650:	if (virt[1] & 0x01) {	// Check group (multicast) bit.
drivers/net/fddi/skfp/skfddi.c:1652:		smc->os.MacStat.gen.multicast++;
drivers/net/fddi/skfp/h/supern_2.h:99:	unsigned int	rx_sadrrg :1 ;	/* DA == MA or broad-/multicast */
drivers/net/fddi/skfp/h/supern_2.h:117:	unsigned int	rx_sadrrg :1 ;	/* DA == MA or broad-/multicast */
drivers/net/fddi/skfp/h/supern_2.h:131:#define RD_S_SADRRG	0x00800000L	/* DA == MA or broad-/multicast */
drivers/net/fddi/skfp/h/fplustm.h:217:	 * multicast table
drivers/net/fddi/defxx.h:1737:	/* Storage for unicast and multicast address entries in adapter CAM */
drivers/net/fddi/defxx.h:1742:	u32				mc_count;						/* number of multicast addresses */
drivers/net/fddi/defxx.h:1747:	u32				group_prom;					/* LLC group (multicast) frame prom mode */
drivers/net/vmxnet3/vmxnet3_ethtool.c:161:		stats->multicast +=  devRxStats->mcastPktsRxOK;
drivers/net/vmxnet3/vmxnet3_defs.h:507:	VMXNET3_RXM_MCAST     = 0x02,  /* multicast passing the filters */
drivers/net/vmxnet3/vmxnet3_defs.h:509:	VMXNET3_RXM_ALL_MULTI = 0x08,  /* all multicast */
drivers/net/vmxnet3/vmxnet3_defs.h:515:	__le16		mfTableLen;   /* size of the multicast filter table */
drivers/net/vmxnet3/vmxnet3_defs.h:517:	__le64		mfTablePA;    /* PA of the multicast filters table */
drivers/net/dummy.c:43:/* fake multicast ability */
drivers/usb/wusbcore/reservation.c:24: * WUSB cluster reservations are multicast reservations with the
drivers/infiniband/hw/mlx4/qp.c:1020:	 * We only support LSO, vendor flag1, and multicast loopback blocking,
drivers/infiniband/hw/mlx4/main.c:1178:		pr_err("multicast attach op failed, err %d\n", err);
drivers/infiniband/hw/mlx4/ah.c:101:	 * HW requires multicast LID so we just choose one.
drivers/infiniband/hw/qib/qib_verbs.c:90:		 "Maximum number of multicast groups to support");
drivers/infiniband/hw/qib/qib_verbs.c:1789:	/* A multicast address requires a GRH (see ch. 8.4.1). */
drivers/infiniband/hw/qib/qib_verbs.h:206: * There is one struct qib_mcast for each multicast GID.
drivers/infiniband/hw/qib/qib_verbs.h:685:	u64 n_multicast_xmit;   /* total multicast packets sent */
drivers/infiniband/hw/qib/qib_verbs.h:686:	u64 n_multicast_rcv;    /* total multicast packets received */
drivers/infiniband/hw/qib/qib_ud.c:333:		 * Don't worry about sending to locally attached multicast
drivers/infiniband/hw/qib/qib_ud.c:369:	 * Use the multicast QP if the destination LID is a multicast LID.
drivers/infiniband/hw/qib/qib_verbs_mcast.c:69: * qib_mcast_alloc - allocate the multicast GID structure
drivers/infiniband/hw/qib/qib_verbs_mcast.c:70: * @mgid: the multicast GID
drivers/infiniband/hw/qib/qib_verbs_mcast.c:103: * qib_mcast_find - search the global table for the given multicast GID
drivers/infiniband/hw/qib/qib_verbs_mcast.c:105: * @mgid: the multicast GID to search for
drivers/infiniband/hw/mthca/mthca_main.c:112:MODULE_PARM_DESC(num_mcg, "maximum number of multicast groups per HCA");
drivers/infiniband/hw/mthca/mthca_main.c:505:	 * whole multicast group table now.  The table isn't very big
drivers/infiniband/hw/mthca/mthca_main.c:808:			  "multicast group table, aborting.\n");
drivers/infiniband/hw/mthca/mthca_cmd.c:135:	/* multicast commands */
drivers/infiniband/hw/mthca/mthca_cmd.c:1398:	/* multicast attributes */
drivers/infiniband/hw/ipath/ipath_verbs_mcast.c:80: * ipath_mcast_alloc - allocate the multicast GID structure
drivers/infiniband/hw/ipath/ipath_verbs_mcast.c:81: * @mgid: the multicast GID
drivers/infiniband/hw/ipath/ipath_verbs_mcast.c:114: * ipath_mcast_find - search the global table for the given multicast GID
drivers/infiniband/hw/ipath/ipath_verbs_mcast.c:115: * @mgid: the multicast GID to search for
drivers/infiniband/hw/ipath/ipath_ud.c:335:		 * Don't worry about sending to locally attached multicast
drivers/infiniband/hw/ipath/ipath_ud.c:370:	 * Use the multicast QP if the destination LID is a multicast LID.
drivers/infiniband/hw/ipath/ipath_verbs.h:152: * There is one struct ipath_mcast for each multicast GID.
drivers/infiniband/hw/ipath/ipath_verbs.h:584:	u64 n_multicast_xmit;	/* total multicast packets sent */
drivers/infiniband/hw/ipath/ipath_verbs.h:585:	u64 n_multicast_rcv;	/* total multicast packets received */
drivers/infiniband/hw/ipath/ipath_verbs.c:91:		 "Maximum number of multicast groups to support");
drivers/infiniband/hw/ipath/ipath_verbs.c:1770:	/* A multicast address requires a GRH (see ch. 8.4.1). */
drivers/infiniband/hw/ipath/ipath_verbs.c:2234:		ipath_dev_err(dev->dd, "multicast table memory leak!\n");
drivers/infiniband/core/sa_query.c:1261:		printk(KERN_ERR "Couldn't initialize multicast handling\n");
drivers/infiniband/core/cma.c:155:	} multicast;
drivers/infiniband/core/cma.c:268:	kfree(mc->multicast.ib);
drivers/infiniband/core/cma.c:1018:			ib_sa_free_multicast(mc->multicast.ib);
drivers/infiniband/core/cma.c:3130:static int cma_ib_mc_handler(int status, struct ib_sa_multicast *multicast)
drivers/infiniband/core/cma.c:3133:	struct cma_multicast *mc = multicast->context;
drivers/infiniband/core/cma.c:3143:		status = cma_set_qkey(id_priv, be32_to_cpu(multicast->rec.qkey));
drivers/infiniband/core/cma.c:3146:		status = ib_attach_mcast(id_priv->id.qp, &multicast->rec.mgid,
drivers/infiniband/core/cma.c:3147:					 be16_to_cpu(multicast->rec.mlid));
drivers/infiniband/core/cma.c:3156:					 id_priv->id.port_num, &multicast->rec,
drivers/infiniband/core/cma.c:3159:		event.param.ud.qkey = be32_to_cpu(multicast->rec.qkey);
drivers/infiniband/core/cma.c:3242:	mc->multicast.ib = ib_sa_join_multicast(&sa_client, id_priv->id.device,
drivers/infiniband/core/cma.c:3246:	return PTR_ERR_OR_ZERO(mc->multicast.ib);
drivers/infiniband/core/cma.c:3253:	struct ib_sa_multicast *m = mc->multicast.ib;
drivers/infiniband/core/cma.c:3255:	mc->multicast.ib->context = mc;
drivers/infiniband/core/cma.c:3303:	mc->multicast.ib = kzalloc(sizeof(struct ib_sa_multicast), GFP_KERNEL);
drivers/infiniband/core/cma.c:3304:	if (!mc->multicast.ib) {
drivers/infiniband/core/cma.c:3309:	cma_iboe_set_mgid(addr, &mc->multicast.ib->rec.mgid);
drivers/infiniband/core/cma.c:3311:	mc->multicast.ib->rec.pkey = cpu_to_be16(0xffff);
drivers/infiniband/core/cma.c:3313:		mc->multicast.ib->rec.qkey = cpu_to_be32(RDMA_UDP_QKEY);
drivers/infiniband/core/cma.c:3321:	mc->multicast.ib->rec.rate = iboe_get_rate(ndev);
drivers/infiniband/core/cma.c:3322:	mc->multicast.ib->rec.hop_limit = 1;
drivers/infiniband/core/cma.c:3323:	mc->multicast.ib->rec.mtu = iboe_get_mtu(ndev->mtu);
drivers/infiniband/core/cma.c:3325:	if (!mc->multicast.ib->rec.mtu) {
drivers/infiniband/core/cma.c:3330:		    &mc->multicast.ib->rec.port_gid);
drivers/infiniband/core/cma.c:3340:	kfree(mc->multicast.ib);
drivers/infiniband/core/cma.c:3413:						&mc->multicast.ib->rec.mgid,
drivers/infiniband/core/cma.c:3414:						be16_to_cpu(mc->multicast.ib->rec.mlid));
drivers/infiniband/core/cma.c:3418:					ib_sa_free_multicast(mc->multicast.ib);
drivers/infiniband/core/Makefile:17:ib_sa-y :=			sa_query.o multicast.o
drivers/infiniband/core/multicast.c:116:	struct ib_sa_multicast	multicast;
drivers/infiniband/core/multicast.c:223: * A multicast group has three types of members: full member, non member, and
drivers/infiniband/core/multicast.c:238: * If a multicast group has zero members left for a particular join state, but
drivers/infiniband/core/multicast.c:338:				       &member->multicast.rec,
drivers/infiniband/core/multicast.c:339:				       member->multicast.comp_mask,
drivers/infiniband/core/multicast.c:379:	member->multicast.rec = group->rec;
drivers/infiniband/core/multicast.c:380:	member->multicast.rec.join_state = join_state;
drivers/infiniband/core/multicast.c:390:	return member->multicast.callback(status, &member->multicast);
drivers/infiniband/core/multicast.c:414:		adjust_membership(group, member->multicast.rec.join_state, -1);
drivers/infiniband/core/multicast.c:418:		ret = member->multicast.callback(-ENETRESET,
drivers/infiniband/core/multicast.c:419:						 &member->multicast);
drivers/infiniband/core/multicast.c:422:			ib_sa_free_multicast(&member->multicast);
drivers/infiniband/core/multicast.c:436:	struct ib_sa_multicast *multicast;
drivers/infiniband/core/multicast.c:454:		multicast = &member->multicast;
drivers/infiniband/core/multicast.c:455:		join_state = multicast->rec.join_state;
drivers/infiniband/core/multicast.c:459:			status = cmp_rec(&group->rec, &multicast->rec,
drivers/infiniband/core/multicast.c:460:					 multicast->comp_mask);
drivers/infiniband/core/multicast.c:466:			ret = multicast->callback(status, multicast);
drivers/infiniband/core/multicast.c:479:			ib_sa_free_multicast(&member->multicast);
drivers/infiniband/core/multicast.c:511:		ret = member->multicast.callback(status, &member->multicast);
drivers/infiniband/core/multicast.c:514:			ib_sa_free_multicast(&member->multicast);
drivers/infiniband/core/multicast.c:612:				     struct ib_sa_multicast *multicast),
drivers/infiniband/core/multicast.c:617:	struct ib_sa_multicast *multicast;
drivers/infiniband/core/multicast.c:630:	member->multicast.rec = *rec;
drivers/infiniband/core/multicast.c:631:	member->multicast.comp_mask = comp_mask;
drivers/infiniband/core/multicast.c:632:	member->multicast.callback = callback;
drivers/infiniband/core/multicast.c:633:	member->multicast.context = context;
drivers/infiniband/core/multicast.c:646:	 * The user will get the multicast structure in their callback.  They
drivers/infiniband/core/multicast.c:647:	 * could then free the multicast structure before we can return from
drivers/infiniband/core/multicast.c:651:	multicast = &member->multicast;
drivers/infiniband/core/multicast.c:653:	return multicast;
drivers/infiniband/core/multicast.c:662:void ib_sa_free_multicast(struct ib_sa_multicast *multicast)
drivers/infiniband/core/multicast.c:667:	member = container_of(multicast, struct mcast_member, multicast);
drivers/infiniband/core/multicast.c:672:		adjust_membership(group, multicast->rec.join_state, -1);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:55:		 "Enable multicast debug tracing if > 0");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:74:	ipoib_dbg_mcast(netdev_priv(dev), "deleting multicast group %pI6\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:178:	/* Set the multicast MTU and cached Q_Key before we attach if it's
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:203:			ipoib_warn(priv, "multicast group %pI6 already attached\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:212:			ipoib_warn(priv, "couldn't attach QP to multicast group %pI6\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:275:				   struct ib_sa_multicast *multicast)
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:277:	struct ipoib_mcast *mcast = multicast->context;
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:285:		status = ipoib_mcast_join_finish(mcast, &multicast->rec);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:289:			ipoib_dbg_mcast(netdev_priv(dev), "multicast join failed for %pI6, status %d\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:321:		ipoib_dbg_mcast(priv, "device shutting down, no multicast joins\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:326:		ipoib_dbg_mcast(priv, "multicast entry busy, skipping\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:349:		ipoib_dbg_mcast(priv, "no multicast record for %pI6, starting join\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:379:				     struct ib_sa_multicast *multicast)
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:381:	struct ipoib_mcast *mcast = multicast->context;
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:395:		status = ipoib_mcast_join_finish(mcast, &multicast->rec);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:418:			ipoib_dbg_mcast(priv, "multicast join failed for %pI6, status %d\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:421:			ipoib_warn(priv, "multicast join failed for %pI6, status %d\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:602:	ipoib_dbg_mcast(priv, "successfully joined all multicast groups\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:611:	ipoib_dbg_mcast(priv, "starting multicast thread\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:625:	ipoib_dbg_mcast(priv, "stopping multicast thread\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:650:		/* Remove ourselves from the multicast group */
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:680:		ipoib_dbg_mcast(priv, "setting up send only multicast group for %pI6\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:686:				   "multicast structure\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:708:					"but multicast join already started\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:752:	ipoib_dbg_mcast(priv, "flushing multicast list\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:803:	ipoib_dbg_mcast(priv, "restarting multicast task\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:813:	 * the multicast hardware addresses. We need to figure out which ones
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:837:				ipoib_dbg_mcast(priv, "ignoring multicast entry for mgid %pI6\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:843:			ipoib_dbg_mcast(priv, "adding multicast entry for mgid %pI6\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:848:				ipoib_warn(priv, "unable to allocate memory for multicast structure\n");
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:877:			ipoib_dbg_mcast(priv, "deleting multicast group %pI6\n",
drivers/infiniband/ulp/ipoib/ipoib_ib.c:259:	 * Drop packets that this interface sent, ie multicast packets
drivers/infiniband/ulp/ipoib/ipoib_ib.c:283:	/* First byte of dgid signals multicast when 0xff */
drivers/infiniband/ulp/ipoib/ipoib_ib.c:1101: * mechanism. It is using the same approach implemented for the multicast
drivers/infiniband/ulp/ipoib/ipoib.h:135:/* Used for all multicast joins (broadcast, IPv4 mcast and IPv6 mcast) */
drivers/infiniband/ulp/ipoib/ipoib_main.c:208:			ipoib_warn(priv, "mtu > %d will cause multicast packet drops.\n",
drivers/infiniband/ulp/ipoib/ipoib_main.c:233:			   "will cause multicast packet drops\n");
drivers/infiniband/ulp/ipoib/ipoib_main.c:726:		/* multicast, arrange "if" according to probability */
drivers/infiniband/ulp/ipoib/ipoib_main.c:737:		/* Add in the P_Key for multicast*/
drivers/infiniband/ulp/ipoib/ipoib_main.c:1428:		ipoib_warn(priv, "ignoring multicast groups joined directly "
drivers/infiniband/ulp/ipoib/ipoib_verbs.c:67:	/* attach QP to multicast group */
drivers/infiniband/ulp/ipoib/ipoib_verbs.c:70:		ipoib_warn(priv, "failed to attach to multicast group, ret = %d\n", ret);
drivers/infiniband/ulp/ipoib/Kconfig:23:	  drops for multicast and UD mode traffic from this interface,
drivers/infiniband/ulp/ipoib/Kconfig:38:	  information about IB multicast groups used by the IPoIB
drivers/staging/gdm724x/gdm_lte.c:795:	/* if zero address or multicast bit set, restore the default value */
drivers/staging/octeon/ethernet.c:247:		priv->stats.multicast += rx_status.multicast_packets;
drivers/staging/octeon/ethernet.c:332: * cvm_oct_common_set_multicast_list - set the multicast list
drivers/staging/octeon/ethernet.c:351:			/* Force accept multicast packets */
drivers/staging/octeon/ethernet.c:354:			/* Force reject multicast packets */
drivers/staging/netlogic/xlr_net.c:386:	stats->multicast = xlr_nae_rdreg(priv->base_addr,
drivers/staging/rtl8187se/ieee80211/ieee80211.h:937:			   * with RX of broad/multicast frames */
drivers/staging/rtl8187se/ieee80211/ieee80211_rx.c:538:			/* This seems to be triggered by some (multicast?)
drivers/staging/rtl8187se/ieee80211/ieee80211_tx.c:418:		 * Determine fragmentation size based on destination (multicast
drivers/staging/vt6655/tether.c:28: *      ETHbyGetHashIndexByCrc32 - Calculate multicast hash value by CRC32
drivers/staging/vt6655/tether.c:51: * Description: Calculate multicast hash value by CRC32
drivers/staging/vt6655/hostap.c:429:	// reserved node index =0 for multicast node.
drivers/staging/vt6655/bssdb.c:1049:					/* ii = 0 for multicast node (AP & Adhoc) */
drivers/staging/vt6655/bssdb.c:1125:	/* check if any STA in PS mode, enable DTIM multicast deliver */
drivers/staging/vt6655/dpc.c:1014:						// Once if STA in PS state, enable multicast bufferring
drivers/staging/vt6655/dpc.c:1346:				DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
drivers/staging/vt6655/tether.h:44:#define U_MULTI_ADDR_LEN    8           // multicast address length
drivers/staging/vt6655/mac.c:241: *      Set this hash index into multicast address register bit
drivers/staging/vt6655/mac.c:272: *      Reset this hash index into multicast address register bit
drivers/staging/vt6655/mac.c:586:	// if only in DIRECTED mode, multicast-address will set to zero,
drivers/staging/vt6655/mac.c:587:	// but if other mode exist (e.g. PROMISCUOUS), multicast-address
drivers/staging/vt6655/mac.c:590:		// set multicast address to accept none
drivers/staging/vt6655/mac.c:598:		// set multicast address to accept all
drivers/staging/rtl8188eu/include/rtl8188e_spec.h:730:#define	RCR_AM			BIT2	/* Accept multicast packet */
drivers/staging/rtl8188eu/include/rtw_mp_phy_regdef.h:1063:#define RCR_AM		BIT(2)		/*  accept multicast */
drivers/staging/rtl8188eu/hal/rtl8188eu_xmit.c:334:	/*  (1) The sequence number of each non-Qos frame / broadcast / multicast / */
drivers/staging/rtl8188eu/hal/usb_halinit.c:377:	/*  Accept all multicast address */
drivers/staging/rtl8188eu/hal/usb_halinit.c:2182:	case 1:/* for broadcast/multicast */
drivers/staging/rtl8188eu/core/rtw_xmit.c:1098:			/*  don't do fragment to broadcat/multicast packets */
drivers/staging/rtl8188eu/core/rtw_sta_mgt.c:532:	/*  default broadcast & multicast use macid 1 */
drivers/staging/rtl8188eu/core/rtw_br_ext.c:526:			/* some multicast with source IP is all zero, maybe other case is illegal */
drivers/staging/rtl8188eu/core/rtw_recv.c:784:		/*  filter packets that SA is myself or multicast or broadcast */
drivers/staging/rtl8188eu/core/rtw_recv.c:879:		/*  filter packets that SA is myself or multicast or broadcast */
drivers/staging/rtl8188eu/os_dep/xmit_linux.c:232:			return false;	/*  Caller shall tx this multicast frame via normal way. */
drivers/staging/slicoss/slicoss.c:217:		/* Turn on all multicast addresses. We have to do this for
drivers/staging/slicoss/slicoss.c:226:		/* Commit our multicast mast to the SLIC by writing to the
drivers/staging/slicoss/slicoss.c:227:		 * multicast address mask registers
drivers/staging/slicoss/slicoss.c:642:	/* Write our multicast mask out to the card.  This is done */
drivers/staging/slicoss/slicoss.c:783:			netdev->stats.multicast++;
drivers/staging/slicoss/slicoss.c:793:					netdev->stats.multicast++;
drivers/staging/slicoss/slicoss.c:2079:			netdev->stats.multicast);
drivers/staging/slicoss/slicoss.c:2313: *  Allocate a mcast_address structure to hold the multicast address.
drivers/staging/slicoss/slicoss.c:3000:	/* free multicast addresses */
drivers/staging/vt6656/hostap.c:386:    // reserved node index =0 for multicast node.
drivers/staging/vt6656/int.c:140:					/* check if multicast tx buffering */
drivers/staging/vt6656/bssdb.c:917:					/* ii = 0 for multicast node (AP & Adhoc) */
drivers/staging/vt6656/bssdb.c:988:	/* Check if any STA in PS mode, enable DTIM multicast deliver */
drivers/staging/vt6656/dpc.c:935:                       // Once if STA in PS state, enable multicast bufferring
drivers/staging/vt6656/dpc.c:1234:               DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
drivers/staging/vt6656/rxtx.c:2128:            // multicast/broadcast data rate
drivers/staging/vt6656/tether.h:39:#define U_MULTI_ADDR_LEN    8           // multicast address length
drivers/staging/rtl8712/usb_intf.c:580:			/* Make sure the user did not select a multicast
drivers/staging/rtl8712/rtl871x_recv.c:329:		/* filter packets that SA is myself or multicast or broadcast */
drivers/staging/rtl8712/rtl871x_recv.c:404:		/* filter packets that SA is myself or multicast or broadcast */
drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h:1003:#define RCR_AM		BIT(2)		/* accept multicast */
drivers/staging/winbond/wb35reg_s.h:108:		u8		Multicast[8];	/* contents of card multicast registers */
drivers/staging/winbond/wbusb.c:103:				    u64 multicast)
drivers/staging/winbond/wbusb.c:111:	else if ((*total_flags & FIF_ALLMULTI) || (multicast > 32))
drivers/staging/winbond/reg.c:811: *    For a given multicast address, returns the byte and bit in the card multicast registers that it hashes to.
drivers/staging/wlags49_h2/wl_main.c:1921:				Clearing the multicast bit
drivers/staging/wlags49_h2/man/wlags49.4:350:Controls buffering of multicast MAC frames for transmission after DTIM. If no,
drivers/staging/wlags49_h2/man/wlags49.4:351:multicast MAC frames are directly placed in the output queue.
drivers/staging/wlags49_h2/man/wlags49.4:356:Sets the data rate for multicast message transmission.
drivers/staging/wlags49_h2/man/wlags49.4:366:rate to multicast, where the rates supported are as follows:
drivers/staging/wlags49_h2/man/wlags49.4:378:Enable or disable receiving of all multicast packets when Card Power Management
drivers/staging/wlags49_h2/man/wlags49.4:380:to receive the multicast frames. This causes less optimal power savings.
drivers/staging/wlags49_h2/wl_netdev.c:976: *      Function to handle multicast packets
drivers/staging/wlags49_h2/wl_netdev.c:1022:            DBG_TRACE( DbgInfo, "Skipping multicast, in RTS mode\n" );
drivers/staging/wlags49_h2/wl_netdev.c:1041:                /* Shutting off this filter will enable all multicast frames to
drivers/staging/wlags49_h2/wl_netdev.c:1047:                DBG_PRINT( "Enabling all multicast mode (IFF_ALLMULTI)\n" );
drivers/staging/wlags49_h2/wl_netdev.c:1052:                /* Set the multicast addresses */
drivers/staging/wlags49_h2/wl_netdev.c:1060:                DBG_PRINT( "Setting multicast list\n" );
drivers/staging/wlags49_h2/wl_netdev.c:1070:                /* Disable multicast mode */
drivers/staging/wlags49_h2/wl_netdev.c:1076:                /* Turning on this filter will prevent all multicast frames from
drivers/staging/wlags49_h2/wl_netdev.c:1082:                DBG_PRINT( "Disabling all multicast mode (IFF_ALLMULTI)\n" );
drivers/staging/wlags49_h2/wl_netdev.c:1102:#error Obsolete set multicast interface!
drivers/staging/rtl8192u/r819xU_cmdpkt.h:103:	u16	txmcok;				/* Tx multicast */
drivers/staging/rtl8192u/r8192U_hw.h:158:#define	RCR_AM			BIT2			// Accept multicast packet
drivers/staging/rtl8192u/ieee80211/ieee80211.h:1893:	/* host performs multicast decryption */
drivers/staging/rtl8192u/ieee80211/ieee80211.h:1922:			   * with RX of broad/multicast frames */
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:2153:		ieee->stats.multicast++;
drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c:994:		 * even with broad/multicast targets (this is against IEEE
drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c:1010:			/* This seems to be triggered by some (multicast?)
drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c:1349:					stats->multicast++;
drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c:700:		/* Determine fragmentation size based on destination (multicast
drivers/staging/rtl8192u/r819xU_cmdpkt.c:102:	   broadcast or uni or multicast. So the relative statistics
drivers/staging/rtl8192u/r819xU_cmdpkt.c:110:		/* We can not make sure broadcast/multicast or unicast mode. */
drivers/staging/rtl8192u/r819xU_cmdpkt.c:126:		/* We can not make sure broadcast/multicast or unicast mode. */
drivers/staging/rtl8192u/r819xU_cmdpkt.c:181:	   or multicast. */
drivers/staging/et131x/et131x.c:221: * 24: asw_multicast		has a multicast address
drivers/staging/et131x/et131x.c:500:	/* multicast list */
drivers/staging/et131x/et131x.c:1064:		/* Loop through our multicast array and set up the device */
drivers/staging/et131x/et131x.c:2538:	/* Determine if this is a multicast packet coming in */
drivers/staging/et131x/et131x.c:4127:	stats->multicast = devstat->multicast_pkts_rcvd;
drivers/staging/et131x/et131x.c:4243:		 * multicast entries or (3) we receive none.
drivers/staging/et131x/et131x.c:4294:	/* Clear the 'multicast' flag locally; because we only have a single
drivers/staging/et131x/et131x.c:4295:	 * flag to check multicast, and multiple multicast addresses can be
drivers/staging/et131x/et131x.c:4297:	 * multicast address is being set.
drivers/staging/rtl8821ae/ps.c:563:	/* 2. Maybe the AP wants to send multicast/broadcast data? */
drivers/staging/rtl8821ae/ps.c:569:	 * multicast frames here */
drivers/staging/rtl8821ae/pci.c:607:			 * multicast/broadcast/no_qos data */
drivers/staging/rtl8821ae/core.c:498:				    unsigned int *new_flags, u64 multicast)
drivers/staging/rtl8821ae/core.c:513:				 ("Enable receive multicast frame.\n"));
drivers/staging/rtl8821ae/core.c:518:				 ("Disable receive multicast frame.\n"));
drivers/staging/wlan-ng/p80211netdev.c:302:						   isn't multicast */
drivers/staging/wlan-ng/p80211netdev.c:467:* promiscuous mode or rewrite the multicast list.
drivers/staging/wlan-ng/p80211netdev.c:479:	/* TODO:  real multicast support as well */
drivers/staging/wlan-ng/cfg80211.c:282:				  u8 key_index, bool unicast, bool multicast)
drivers/staging/rtl8192e/rtllib_rx.c:886:				     struct sk_buff *skb, u8 multicast)
drivers/staging/rtl8192e/rtllib_rx.c:1033:			/* This seems to be triggered by some (multicast?)
drivers/staging/rtl8192e/rtllib_rx.c:1237:				ieee->stats.multicast++;
drivers/staging/rtl8192e/rtllib_rx.c:1262:	u8 type, stype, multicast = 0, unicast = 0, nr_subframes = 0, TID = 0;
drivers/staging/rtl8192e/rtllib_rx.c:1275:	multicast = is_multicast_ether_addr(hdr->addr1);
drivers/staging/rtl8192e/rtllib_rx.c:1276:	unicast = !multicast;
drivers/staging/rtl8192e/rtllib_rx.c:1292:	ret = rtllib_rx_check_duplicate(ieee, skb, multicast);
drivers/staging/rtl8192e/rtllib_softmac.c:2482:		ieee->stats.multicast++;
drivers/staging/rtl8192e/rtllib_tx.c:704:		/* Determine fragmentation size based on destination (multicast
drivers/staging/rtl8192e/rtllib.h:2164:	/* host performs multicast decryption */
drivers/staging/rtl8192e/rtllib.h:2194:			   * with RX of broad/multicast frames */
drivers/media/dvb-core/dvb_net.c:676:							/* multicast or broadcast */
drivers/media/dvb-core/dvb_net.c:678:								/* multicast */
drivers/media/dvb-core/dvb_net.c:689:								/* else: all multicast mode: accept all multicast packets */
drivers/s390/cio/qdio.h:343:/* the highest iqdio queue is used for multicast */
drivers/s390/net/lcs.c:456:	/* Free multicast list. */
drivers/s390/net/lcs.c:1066: * check if multicast is supported by LCS
drivers/s390/net/lcs.c:1106: * set or del multicast address on LCS card
drivers/s390/net/lcs.c:1130:				pr_info("Adding multicast address failed."
drivers/s390/net/lcs.c:1171: * function called by net device to handle multicast address relevant things
drivers/s390/net/lcs.c:1241:				" new multicast entry!\n");
drivers/s390/net/lcs.c:1292: * handle multicast address relevant things
drivers/s390/net/qeth_l3_main.c:1226:			"Starting multicast support for %s failed\n",
drivers/s390/net/qeth_l3_main.c:1888:			card->stats.multicast++;
drivers/s390/net/qeth_l3_main.c:1894:			card->stats.multicast++;
drivers/s390/net/qeth_l3_main.c:2748:		/* tr multicast? */
drivers/s390/net/qeth_l3_main.c:2756:		/* eth or so multicast? */
drivers/s390/net/lcs.h:76: * LCS IPASSIST MASKS,only used when multicast is switched on
drivers/s390/net/lcs.h:131: * seems to be only used for multicast
drivers/s390/net/qeth_l3_sys.c:26:			return sprintf(buf, "%s\n", "multicast router+");
drivers/s390/net/qeth_l3_sys.c:28:			return sprintf(buf, "%s\n", "multicast router");
drivers/dma/ppc4xx/adma.c:2550:		/* this is the page to multicast source data to */
drivers/misc/sgi-xp/xpnet.c:559:	 * Multicast assumes the LSB of the first octet is set for multicast
drivers/misc/sgi-xp/xpnet.c:569:	 * ether_setup() sets this to a multicast device.  We are
drivers/misc/sgi-xp/xpnet.c:570:	 * really not supporting multicast at this time.
drivers/scsi/fnic/fnic_main.c:758:		/* enable directed and multicast */
drivers/scsi/fnic/vnic_dev.c:472:void vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,
drivers/scsi/fnic/vnic_dev.c:480:	     (multicast ? CMD_PFILTER_MULTICAST : 0) |
drivers/scsi/fnic/vnic_dev.h:133:void vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,
drivers/scsi/lpfc/lpfc_hw.h:366:	uint16_t multicast:1;	/* FC Word 1, bit 25 */
drivers/scsi/lpfc/lpfc_hw.h:377:	uint16_t multicast:1;	/* FC Word 1, bit 25 */
drivers/scsi/bfa/bfa_defs_svc.h:657:	u64	txf_mcast;	/*  Tx FCoE multicast frames	     */
drivers/scsi/bfa/bfa_defs_svc.h:658:	u64	txf_mcast_vlan;	/*  Tx FCoE multicast vlan frames    */
drivers/scsi/bfa/bfa_defs_svc.h:659:	u64	txf_mcast_octets; /*  Tx FCoE multicast octets	     */
drivers/scsi/bfa/bfa_defs_svc.h:669:	u64	rxf_mcast_octets; /*  Rx FCoE multicast octets	     */
drivers/scsi/bfa/bfa_defs_svc.h:670:	u64	rxf_mcast;	/*  Rx FCoE multicast frames	     */
drivers/scsi/bfa/bfa_defs_svc.h:671:	u64	rxf_mcast_vlan;	/*  Rx FCoE multicast vlan frames    */
drivers/scsi/bfa/bfa_defs_svc.h:1293:	u64     tx_mcast_packets; /*  Tx multicast packets      */
drivers/scsi/bfa/bfa_defs_svc.h:1302:	u64     rx_mcast_packets; /*  Rx multicast packets      */
drivers/scsi/pmcraid.c:1413:	 * Due to prior multicast group abuse (the code having assumed that
drivers/scsi/pmcraid.c:1414:	 * the family ID can be used as a multicast group ID) we need to
drivers/scsi/pmcraid.c:1516:	/* send genetlink multicast message to notify appplications */
drivers/scsi/fcoe/fcoe_ctlr.c:382: * @fcf: The destination FCF (if NULL, a multicast solicitation is sent)
drivers/scsi/fcoe/fcoe_ctlr.c:1101:	 * the first advertisement we've received, do a multicast
drivers/scsi/fcoe/fcoe_ctlr.c:1111:	 * the FCF that answers multicast solicitations, not the others that
drivers/scsi/fcoe/fcoe_ctlr.c:1112:	 * are sending periodic multicast advertisements.
drivers/scsi/fcoe/fcoe_ctlr.c:2356: * fcoe_ctlr_vn_send_claim() - send multicast FIP VN2VN Claim Notification.
arch/xtensa/platforms/iss/network.c:137:		pr_err("%s: attempt to assign a multicast ethernet address\n",
arch/arc/plat-arcfpga/smp.c:70:	 * TBD: Have a dedicated multicast IRQ for sending IPIs to all CPUs
arch/um/drivers/net_kern.c:320:		       "Attempt to assign a multicast ethernet address to a "
arch/um/drivers/umcast_kern.c:2: * user-mode-linux networking multicast transport
arch/um/drivers/umcast_kern.c:46:		printk(KERN_INFO "mcast backend multicast address: %s:%u, "
arch/um/drivers/umcast_user.c:2: * user-mode-linux networking multicast transport
arch/um/drivers/umcast_user.c:123:		/* subscribe to the multicast group */
arch/um/drivers/umcast_user.c:132:			       "multicast-capable network interface on the "
arch/um/drivers/umcast_user.c:135:			       "to use the multicast transport.\n");
arch/mips/include/asm/octeon/cvmx-pip.h:195:	 * Number of identified L2 multicast packets.	Does not
arch/mips/include/asm/octeon/cvmx-pip.h:202:	 * include multicast packets.  Only includes packets whose
arch/mips/include/asm/mach-rc32434/eth.h:96:/* Ethernet ARC/multicast registers */
arch/mips/kernel/cevt-smtc.c:34: * multicast mechanisms "under the hood", appearing to the
arch/ia64/hp/sim/simeth.c:502:/* fake multicast ability */
arch/blackfin/mach-bf609/include/mach/defBF60x_base.h:1038:#define EMAC0_TXMCASTFRM_G          0xFFC20120         /* EMAC0 Number of good multicast frames transmitted. */
arch/blackfin/mach-bf609/include/mach/defBF60x_base.h:1046:#define EMAC0_TXMCASTFRM_GB         0xFFC20140         /* EMAC0 Number of good and bad multicast frames transmitted */
arch/blackfin/mach-bf609/include/mach/defBF60x_base.h:1064:#define EMAC0_RXMCASTFRM_G          0xFFC20190         /* EMAC0 Number of good multicast frames received */
arch/blackfin/mach-bf609/include/mach/defBF60x_base.h:1173:#define EMAC1_TXMCASTFRM_G          0xFFC22120         /* EMAC1 Number of good multicast frames transmitted. */
arch/blackfin/mach-bf609/include/mach/defBF60x_base.h:1181:#define EMAC1_TXMCASTFRM_GB         0xFFC22140         /* EMAC1 Number of good and bad multicast frames transmitted */
arch/blackfin/mach-bf609/include/mach/defBF60x_base.h:1199:#define EMAC1_RXMCASTFRM_G          0xFFC22190         /* EMAC1 Number of good multicast frames received */
Binary file arch/arm/boot/Image matches
arch/x86/include/asm/uv/uv_bau.h:311:	unsigned int	multilevel:1;		/* multi-level multicast
arch/x86/include/asm/uv/uv_bau.h:375:	unsigned int	multilevel:1;		/* multi-level multicast
arch/powerpc/include/asm/cpm2.h:586:	uint	fen_mulc;	/* Total multicast packet count */
Binary file .tmp_vmlinux2 matches
Binary file .tmp_vmlinux1 matches
Binary file vmlinux matches
security/selinux/hooks.c:4894:	 * NOTE: there appear to be some IPv6 multicast cases where skb->dst
